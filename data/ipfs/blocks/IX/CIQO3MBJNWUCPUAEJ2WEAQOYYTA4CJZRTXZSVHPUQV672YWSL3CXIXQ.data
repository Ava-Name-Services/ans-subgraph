
äÄÄÄxt, quorum, support]\n  )\n\n  return (\n    <form\n      css={`\n        display: grid;\n        align-items: center;\n        justify-content: center;\n      `}\n    >\n      <Header\n        title={title}\n        subtitle={\n          <span\n            css={`\n              display: flex;\n              align-items: center;\n              justify-content: center;\n            `}\n          >\n            Choose your\n            <span\n              css={`\n                display: flex;\n                margin: 0 ${1.5 * GU}px;\n              `}\n            >\n              <KnownAppBadge appName=\"voting.aragonpm.eth\" label={appLabel} />\n            </span>\n            settings below.\n          </span>\n        }\n      />\n\n      <PercentageField\n        ref={handleSupportRef}\n        label={\n          <React.Fragment>\n            Support %\n            <Help hint=\"What is Support?\">\n              <strong>Support</strong> is the relative percentage of tokens that\n              are required to vote ‚ÄúYes‚Äù for a proposal to be approved. For\n              example, if ‚ÄúSupport‚Äù is set to 50%, then more than 50% of the\n              tokens used to vote on a proposal must vote ‚ÄúYes‚Äù for it to pass.\n            </Help>\n          </React.Fragment>\n        }\n        value={support}\n        onChange={handleSupportChange}\n      />\n\n      <PercentageField\n        ref={quorumRef}\n        label={\n          <React.Fragment>\n            Minimum approval %\n            <Help hint=\"What is Minimum Approval?\">\n              <strong>Minimum Approval</strong> is the percentage of the total\n              token supply that is required to vote ‚ÄúYes‚Äù on a proposal before\n              it can be approved. For example, if the ‚ÄúMinimum Approval‚Äù is set\n              to 20%, then more than 20% of the outstanding token supply must\n              vote ‚ÄúYes‚Äù on a proposal for it to pass.\n            </Help>\n          </React.Fragment>\n        }\n        value={quorum}\n        onChange={handleQuorumChange}\n      />\n\n      <Duration\n        duration={duration}\n        onUpdate={handleDurationChange}\n        label={\n          <React.Fragment>\n            Vote duration\n            <Help hint=\"What‚Äôs the vote duration?\">\n              <strong>Vote Duration</strong> is the length of time that the vote\n              will be open for participation. For example, if the Vote Duration\n              is set to 24 hours, then token holders have 24 hours to\n              participate in the vote.\n            </Help>\n          </React.Fragment>\n        }\n      />\n\n      {formError && (\n        <Info\n          mode=\"error\"\n          css={`\n            margin-bottom: ${3 * GU}px;\n          `}\n        >\n          {formError}\n        </Info>\n      )}\n\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        The support and minimum approval thresholds are strict requirements,\n        such that votes will only pass if they achieve approval percentages\n        greater than these thresholds.\n      </Info>\n\n      <Navigation\n        ref={prevNextRef}\n        backEnabled\n        nextEnabled\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </form>\n  )\n}\n\nVotingScreen.propTypes = {\n  appLabel: PropTypes.string,\n  dataKey: PropTypes.string,\n  screenProps: ScreenPropsType.isRequired,\n  title: PropTypes.string,\n}\n\nVotingScreen.defaultProps = {\n  appLabel: 'Voting',\n  dataKey: 'voting',\n  title: 'Configure template',\n}\n\nfunction formatReviewFields(screenData) {\n  return [\n    ['Support %', `${screenData.support}%`],\n    ['Minimum approval %', `${screenData.quorum}%`],\n    ['Vote duration', formatDuration(screenData.duration)],\n  ]\n}\n\nVotingScreen.formatReviewFields = formatReviewFields\nexport default VotingScreen\n","export * from './prop-types'\nexport { default as ClaimDomainScreen } from './screens/ClaimDomainScreen'\nexport { default as DomainField } from '../../components/DomainField/DomainField'\nexport { default as DotVotingScreen } from './screens/DotVotingScreen'\nexport { default as Duration } from './Duration'\nexport { default as FundraisingScreen } from './screens/FundraisingScreen'\nexport { default as Header } from '../../onboarding/Header/Header'\nexport { default as IdentityBadge } from '../../components/IdentityBadge/LocalIdentityBadge'\nexport { default as KnownAppBadge } from './KnownAppBadge'\nexport { default as Navigation } from './Navigation'\nexport { default as PercentageField } from './PercentageField'\nexport { default as ReviewScreen } from './screens/ReviewScreen'\nexport { default as TokensScreen } from './screens/TokensScreen'\nexport { default as VotingScreen } from './screens/VotingScreen'\n","/* eslint-disable react/prop-types */\nimport React from 'react'\nimport BN from 'bn.js'\nimport {\n  ClaimDomainScreen,\n  KnownAppBadge,\n  ReviewScreen,\n  TokensScreen,\n  VotingScreen,\n} from '../kit'\n\nimport header from './header.svg'\nimport icon from './icon.svg'\n\nfunction completeDomain(domain) {\n  return domain ? `${domain}.aragonid.eth` : ''\n}\n\nfunction adjustVotingSettings(support, quorum) {\n  // The max value for both support and quorum is 100% - 1\n  const onePercent = new BN(10).pow(new BN(16))\n  const hundredPercent = onePercent.mul(new BN(100))\n\n  let adjustedSupport = onePercent.mul(new BN(support))\n  if (adjustedSupport.eq(hundredPercent)) {\n    adjustedSupport = adjustedSupport.sub(new BN(1))\n  }\n\n  let adjustedQuorum = onePercent.mul(new BN(quorum))\n  if (adjustedQuorum.eq(hundredPercent)) {\n    adjustedQuorum = adjustedQuorum.sub(new BN(1))\n  }\n\n  return [adjustedSupport.toString(), adjustedQuorum.toString()]\n}\n\nexport default {\n  id: 'company-template.aragonpm.eth',\n  name: 'Company',\n  header,\n  icon,\n  description: `\n    Use transferable tokens to represent ownership stake in your\n    organization. Decisions are made based on stake-weighted voting.\n  `,\n  userGuideUrl:\n    'https://help.aragon.org/article/30-create-a-new-company-organization',\n  sourceCodeUrl:\n    'https://github.com/aragon/dao-templates/tree/templates-company-v1.0.0/templates/company',\n  registry: 'aragonpm.eth',\n  apps: [\n    { appName: 'voting.aragonpm.eth', label: 'Voting' },\n    { appName: 'token-manager.aragonpm.eth', label: 'Tokens' },\n    { appName: 'finance.aragonpm.eth', label: 'Finance' },\n  ],\n  optionalApps: [{ appName: 'agent.aragonpm.eth', label: 'Agent' }],\n  screens: [\n    [\n      data => completeDomain(data.domain) || 'Claim domain',\n      props => <ClaimDomainScreen screenProps={props} />,\n    ],\n    ['Configure template', props => <VotingScreen screenProps={props} />],\n    ['Configure template', props => <TokensScreen screenProps={props} />],\n    [\n      'Review information',\n      props => {\n        const { domain, voting, tokens } = props.data\n        return (\n          <ReviewScreen\n            screenProps={props}\n            items={[\n              {\n                label: 'General info',\n                fields: [\n                  ['Organization template', 'Company'],\n                  ['Name', completeDomain(domain)],\n                ],\n              },\n              {\n                label: (\n                  <KnownAppBadge appName=\"voting.aragonpm.eth\" label=\"Voting\" />\n                ),\n                fields: VotingScreen.formatReviewFields(voting),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"token-manager.aragonpm.eth\"\n                    label=\"Tokens\"\n                  />\n                ),\n                fields: TokensScreen.formatReviewFields(tokens),\n              },\n            ]}\n          />\n        )\n      },\n    ],\n  ],\n  prepareTransactions(createTx, data, networkType) {\n    const financePeriod = 0 // default\n    const hasPayroll = false\n\n    const { domain, optionalApps = [], tokens, voting } = data\n    const useAgentAsVault = optionalApps.includes('agent.aragonpm.eth')\n\n    const { tokenName, tokenSymbol, members } = tokens\n    const baseStake = new BN(10).pow(new BN(18))\n    const stakes = members.map(([_, stake]) =>\n      baseStake.mul(new BN(stake.toString())).toString()\n    )\n    const accounts = members.map(([account]) => account)\n\n    const { support, quorum, duration } = voting\n    const [adjustedSupport, adjustedQuorum] = adjustVotingSettings(\n      support,\n      quorum\n    )\n    const adjustedDuration = new BN(duration).toString()\n    const votingSettings = [adjustedSupport, adjustedQuorum, adjustedDuration]\n\n    // Rinkeby has its gas limit capped at 7M, so some larger 6.5M+ transactions are\n    // often not mined\n    const forceMultipleTransactions =\n      networkType === 'rinkeby' && members.length > 1\n\n    if (!hasPayroll && !forceMultipleTransactions) {\n      return [\n        {\n          name: 'Create organization',\n          transaction: createTx('newTokenAndInstance', [\n            tokenName,\n            tokenSymbol,\n            domain,\n            accounts,\n            stakes,\n            votingSettings,\n            financePeriod,\n            useAgentAsVault,\n          ]),\n        },\n      ]\n    }\n\n    return [\n      {\n        name: 'Create token',\n        transaction: createTx('newToken', [tokenName, tokenSymbol]),\n      },\n      {\n        name: 'Create organization',\n        transaction: createTx('newInstance', [\n          domain,\n          accounts,\n          stakes,\n          votingSettings,\n          financePeriod,\n          useAgentAsVault,\n        ]),\n      },\n    ]\n  },\n}\n","import React, {\n  useCallback,\n  useEffect,\n  useReducer,\n  useState,\n  useRef,\n} from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Button,\n  DropDown,\n  EthIdenticon,\n  Field,\n  GU,\n  Help,\n  IconPlus,\n  IconTrash,\n  Info,\n  RADIUS,\n  TextInput,\n  textStyle,\n  isAddress,\n  useTheme,\n} from '@aragon/ui'\nimport {\n  Duration,\n  Header,\n  IdentityBadge,\n  KnownAppBadge,\n  Navigation,\n  ScreenPropsType,\n} from '../../kit'\nimport {\n  formatDuration,\n  DAY_IN_SECONDS,\n  MINUTE_IN_SECONDS,\n} from '../../kit/kit-utils'\n\nconst DEFAULT_SUPPORT = 50\nconst DEFAULT_QUORUM = 15\nconst DEFAULT_DURATION = DAY_IN_SECONDS\n\nfunction reduceFields(fields, [field, value]) {\n  if (field === 'duration') {\n    return { ...fields, duration: value }\n  }\n  if (field === 'quorum') {\n    return {\n      ...fields,\n      // 100% quorum is not possible, but any adjustments necessary should be handled in the\n      // template frontends themselves\n      quorum: value,\n      support: Math.max(fields.support, value),\n    }\n  }\n  if (field === 'support') {\n    return {\n      ...fields,\n      // 100% support is not possible, but any adjustments necessary should be handled in the\n      // template frontends themselves\n      support: value,\n      quorum: Math.min(fields.quorum, value),\n    }\n  }\n  return fields\n}\n\nfunction useFieldsLayout() {\n  // In its own hook to be adapted for smaller views\n  return `\n    display: grid;\n    grid-template-columns: auto ${12 * GU}px;\n    grid-column-gap: ${1.5 * GU}px;\n  `\n}\n\nfunction validateDuplicateAddresses(members) {\n  const validAddresses = members\n    .map(([address]) => address.toLowerCase())\n    .filter(address => isAddress(address))\n\n  return validAddresses.length === new Set(validAddresses).size\n}\n\nfunction validationError(\n  tokenName,\n  tokenSymbol,\n  members,\n  signatures,\n  duration\n) {\n  if (!members.some(address => isAddress(address))) {\n    return 'You need at least one valid address.'\n  }\n  if (!validateDuplicateAddresses(members)) {\n    return 'One of your members is using the same address than another member. Please ensure every member address is unique.'\n  }\n  if (!tokenName.trim()) {\n    return 'Please add a token name.'\n  }\n  if (!tokenSymbol) {\n    return 'Please add a token symbol.'\n  }\n  if (signatures < 0) {\n    return 'Please ensure that council voting requires at least one signature.'\n  }\n  if (duration < 10 * MINUTE_IN_SECONDS) {\n    return 'Please ensure the vote duration is equal to or longer than 10 minutes.'\n  }\n  return null\n}\n\nfunction Council({\n  dataKey,\n  screenProps: { back, data, next, screenIndex, screens },\n  title,\n}) {\n  const screenData = (dataKey ? data[dataKey] : data) || {}\n\n  const theme = useTheme()\n  const fieldsLayout = useFieldsLayout()\n\n  const [formError, setFormError] = useState()\n  const [focusLastMemberNext, setFocusLastMemberNext] = useState(false)\n  const [tokenName, setTokenName] = useState(screenData.tokenName || '')\n  const [tokenSymbol, setTokenSymbol] = useState(screenData.tokenSymbol || '')\n  const [members, setMembers] = useState(\n    screenData.members && screenData.members.length > 0\n      ? screenData.members\n      : ['']\n  )\n  const [signatures, setSignatures] = useState(\n    screenData.signatures >= 0 ? screenData.signatures : -1\n  )\n  const [{ support, quorum, duration }, updateField] = useReducer(\n    reduceFields,\n    {\n      support: screenData.support || DEFAULT_SUPPORT,\n      quorum: screenData.quorum || DEFAULT_QUORUM,\n      duration: screenData.duration || DEFAULT_DURATION,\n    }\n  )\n\n  const membersRef = useRef()\n\n  // Focus the token name as soon as it becomes available\n  const handleTokenNameRef = useCallback(element => {\n    if (element) {\n      element.focus()\n    }\n  }, [])\n\n  const handleTokenNameChange = useCallback(event => {\n    setFormError(null)\n    setTokenName(event.target.value)\n  }, [])\n\n  const handleTokenSymbolChange = useCallback(event => {\n    setFormError(null)\n    setTokenSymbol(event.target.value.trim().toUpperCase())\n  }, [])\n\n  useEffect(() => {\n    if (!focusLastMemberNext || !membersRef.current) {\n      return\n    }\n\n    setFocusLastMemberNext(false)\n\n    // This could be managed in individual MemberField components, but using\n    // the container with a .member class makes it simpler to manage, since we\n    // want to focus in three cases:\n    //   - A new field is being added.\n    //   - A field is being removed.\n    //   - The first field is being emptied.\n    //\n    const elts = membersRef.current.querySelectorAll('.member')\n    if (elts.length > 0) {\n      elts[elts.length - 1].querySelector('input').focus()\n    }\n  }, [focusLastMemberNext])\n\n  const focusLastMember = useCallback(() => {\n    setFocusLastMemberNext(true)\n  }, [])\n\n  const hideRemoveButton = members.length < 2 && !members[0]\n\n  const disableNext =\n    !tokenName ||\n    !tokenSymbol ||\n    !members.every(account => account && account !== '') ||\n    signatures < 0\n\n  const addMember = useCallback(() => {\n    setFormError(null)\n    setMembers(members => [...members, ''])\n    focusLastMember()\n  }, [focusLastMember])\n\n  const removeMember = useCallback(\n    index => {\n      setFormError(null)\n      setMembers(members =>\n        members.length < 2\n          ? // When the remove button of the last field\n            // gets clicked, we only empty the field.\n            []\n          : members.filter((_, i) => i !== index)\n      )\n      focusLastMember()\n    },\n    [focusLastMember]\n  )\n\n  const updateMember = useCallback((index, updatedAccount) => {\n    setFormError(null)\n    setMembers(members =>\n      members.map((member, i) => (i === index ? updatedAccount : member))\n    )\n  }, [])\n\n  const handleDurationChange = useCallback(value => {\n    setFormError(null)\n    updateField(['duration', value])\n  }, [])\n\n  const handleSignaturesChange = useCallback(\n    (index, items) => {\n      setFormError(null)\n      setSignatures(index)\n      updateField(['support', Math.floor(((index + 1) * 100) / members.length)])\n      updateField(['quorum', Math.floor(((index + 1) * 100) / members.length)])\n    },\n    [members]\n  )\n\n  useEffect(() => {\n    handleSignaturesChange(signatures)\n  }, [handleSignaturesChange, members, signatures])\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n      const error = validationError(\n        tokenName,\n        tokenSymbol,\n        members,\n        signatures,\n        duration\n      )\n      setFormError(error)\n\n      if (!error) {\n        const screenData = {\n          duration,\n          quorum: Math.floor(quorum),\n          members: members.filter(account => isAddress(account)),\n          support: Math.floor(support),\n          tokenName,\n          tokenSymbol,\n          signatures,\n        }\n        const mergedData = dataKey\n          ? { ...data, [dataKey]: screenData }\n          : { ...data, ...screenData }\n\n        next(mergedData)\n      }\n    },\n    [\n      data,\n      dataKey,\n      members,\n      next,\n      tokenName,\n      tokenSymbol,\n      signatures,\n      support,\n      quorum,\n      duration,\n    ]\n  )\n\n  return (\n    <form\n      css={`\n        display: grid;\n        align-items: center;\n        justify-content: center;\n      `}\n    >\n      <Header title={title} />\n      <Subtitle\n        content={\n          <span\n            css={`\n              display: flex;\n              align-items: center;\n              justify-content: flex-start;\n              margin-bottom\n            `}\n          >\n            Choose your\n            <span\n              css={`\n                display: flex;\n                margin: 0 ${1.5 * GU}px;\n              `}\n            >\n              <KnownAppBadge\n                appName=\"token-manager.aragonpm.eth\"\n                label=\"Tokens: Council\"\n              />\n            </span>\n            settings\n          </span>\n        }\n      />\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        These settings determine who should be a member of the council and\n        information related to the token used for determining membership. The\n        council acts similarly to a traditional multisig account.\n      </Info>\n      <div\n        css={`\n          ${fieldsLayout};\n        `}\n      >\n        <Field\n          label={\n            <React.Fragment>\n              Council token name\n              <Help hint=\"What is Council Token Name?\">\n                <strong>Council Token Name</strong> will be the name assigned to\n                the token representing the organization's council.{' '}\n                <em>For example: My Council Token.</em>\n              </Help>\n            </React.Fragment>\n          }\n        >\n          {({ id }) => (\n            <TextInput\n              ref={handleTokenNameRef}\n              id={id}\n              onChange={handleTokenNameChange}\n              placeholder=\"My Council Token\"\n              value={tokenName}\n              wide\n            />\n          )}\n        </Field>\n\n        <Field\n          label={\n            <React.Fragment>\n              Council token symbol\n              <Help hint=\"What is Council Token Symbol?\">\n                <strong>Council Token Symbol</strong> will be the shortened name\n                (typically in capital letters) assigned to the token\n                representing the organization's council.{' '}\n                <em>For example: CNL.</em>\n              </Help>\n            </React.Fragment>\n          }\n        >\n          {({ id }) => (\n            <TextInput\n              id={id}\n              onChange={handleTokenSymbolChange}\n              value={tokenSymbol}\n              placeholder=\"CNL\"\n              wide\n            />\n          )}\n        </Field>\n      </div>\n      <Field\n        label={\n          <div\n            css={`\n              width: 100%;\n              ${fieldsLayout}\n            `}\n          >\n            <div>Council members</div>\n          </div>\n        }\n      >\n        <div ref={membersRef}>\n          {members.map((member, index) => (\n            <MemberField\n              key={index}\n              index={index}\n              member={member}\n              onRemove={removeMember}\n              hideRemoveButton={hideRemoveButton}\n              onUpdate={updateMember}\n            />\n          ))}\n        </div>\n        <Button\n          icon={\n            <IconPlus\n              css={`\n                color: ${theme.accent};\n              `}\n            />\n          }\n          label=\"Add more\"\n          onClick={addMember}\n        />\n      </Field>\n\n      <Subtitle\n        content={\n          <span\n            css={`\n              display: flex;\n              align-items: center;\n              justify-content: flex-start;\n              margin-bottom\n            `}\n          >\n            Choose your\n            <span\n              css={`\n                display: flex;\n                margin: 0 ${1.5 * GU}px;\n              `}\n            >\n              <KnownAppBadge\n                appName=\"voting.aragonpm.eth\"\n                label=\"Voting: Council\"\n              />\n            </span>\n            settings\n          </span>\n        }\n      />\n\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        These settings affect the decision making process for council members.\n      </Info>\n      <Field\n        label={\n          <React.Fragment>\n            Number of signatures\n            <Help hint=\"What is Number of Signatures?\">\n              <strong>Number of Signatures</strong> is the number of council\n              members who need to approve a vote for it to pass.\n            </Help>\n          </React.Fragment>\n        }\n      >\n        <div\n          css={`\n            display: flex;\n            align-items: center;\n          `}\n        >\n          <DropDown\n            items={members.map((value, index) => index + 1)}\n            css={`\n              margin-right: ${1.5 * GU}px;\n            `}\n            selected={signatures}\n            onChange={handleSignaturesChange}\n          />\n          <p>out of {members.length}</p>\n        </div>\n      </Field>\n\n      <Duration\n        duration={duration}\n        onUpdate={handleDurationChange}\n        label={\n          <React.Fragment>\n            Vote duration\n            <Help hint=\"What is Vote Duration?\">\n              <strong>Vote Duration</strong> is the length of time that\n              council's votes will be open for participation. For example, if\n              the Vote Duration is set to 24 hours, then council members will\n              have 24 hours to participate in the vote.\n            </Help>\n          </React.Fragment>\n        }\n      />\n      {formError && (\n        <Info\n          mode=\"error\"\n          css={`\n            margin-bottom: ${3 * GU}px;\n          `}\n        >\n          {formError}\n        </Info>\n      )}\n\n      <Navigation\n        backEnabled\n        nextEnabled={!disableNext}\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </form>\n  )\n}\n\nCouncil.propTypes = {\n  dataKey: PropTypes.string,\n  screenProps: ScreenPropsType.isRequired,\n  title: PropTypes.string,\n}\n\nCouncil.defaultProps = {\n  dataKey: 'council',\n  title: 'Configure council',\n}\n\nCouncil.formatReviewFields = formatReviewFields\n\nfunction Subtitle({ content }) {\n  const theme = useTheme()\n\n  return (\n    <h4\n      css={`\n        ${textStyle('title4')};\n        color: ${theme.contentSecondary};\n        margin-bottom: ${3 * GU}px;\n      `}\n    >\n      {content}\n    </h4>\n  )\n}\n\nSubtitle.propTypes = {\n  content: PropTypes.any,\n}\nfunction MemberField({ index, member, hideRemoveButton, onUpdate, onRemove }) {\n  const theme = useTheme()\n  const fieldsLayout = useFieldsLayout()\n\n  const account = member\n\n  const handleRemove = useCallback(() => {\n    onRemove(index)\n  }, [onRemove, index])\n\n  const handleAccountChange = useCallback(\n    event => {\n      onUpdate(index, event.target.value)\n    },\n    [onUpdate, index]\n  )\n\n  return (\n    <div\n      className=\"member\"\n      css={`\n        ${fieldsLayout};\n        position: relative;\n        margin-bottom: ${1.5 * GU}px;\n      `}\n    >\n      <div>\n        <TextInput\n          adornment={\n            <span css=\"transform: translateY(1px)\">\n              {!hideRemoveButton && (\n                <Button\n                  display=\"icon\"\n                  icon={\n                    <IconTrash\n                      css={`\n                        color: ${theme.negative};\n                      `}\n                    />\n                  }\n                  label=\"Remove\"\n                  onClick={handleRemove}\n                  size=\"mini\"\n                />\n              )}\n            </span>\n          }\n          adornmentPosition=\"end\"\n          adornmentSettings={{ width: 52, padding: 8 }}\n          onChange={handleAccountChange}\n          placeholder=\"Account address\"\n          value={account}\n          wide\n          css={`\n            padding-left: ${4.5 * GU}px;\n          `}\n        />\n        <div\n          css={`\n            position: absolute;\n            top: ${1 * GU}px;\n            left: ${1 * GU}px;\n          `}\n        >\n          {isAddress(account) ? (\n            <EthIdenticon address={account} radius={RADIUS} />\n          ) : (\n            <div\n              css={`\n                width: ${3 * GU}px;\n                height: ${3 * GU}px;\n                background: ${theme.disabled};\n                border-radius: ${RADIUS}px;\n              `}\n            />\n          )}\n        </div>\n      </div>\n    </div>\n  )\n}\n\nMemberField.propTypes = {\n  hideRemoveButton: PropTypes.bool.isRequired,\n  index: PropTypes.number.isRequired,\n  member: PropTypes.string.isRequired,\n  onRemove: PropTypes.func.isRequired,\n  onUpdate: PropTypes.func.isRequired,\n}\n\nfunction formatReviewFields(screenData) {\n  return [\n    [\n      'Token name & symbol',\n      `${screenData.tokenName} (${screenData.tokenSymbol})`,\n    ],\n    ...screenData.members.map((account, i) => [\n      `Tokenholder #${i + 1}`,\n      <div\n        css={`\n          display: flex;\n          align-items: center;\n        `}\n      >\n        <IdentityBadge entity={account} />\n        <span\n          css={`\n            margin-left: ${2 * GU}px;\n          `}\n        />\n      </div>,\n    ]),\n    [\n      'Signatures',\n      `${screenData.signatures + 1} out of ${screenData.members.length}`,\n    ],\n    ['Support %', `${screenData.support}%`],\n    ['Minimum approval %', `${screenData.quorum}%`],\n    ['Vote duration', formatDuration(screenData.duration)],\n  ]\n}\n\nexport default Council\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, useTheme } from '@aragon/ui'\nimport { Header, Navigation, ScreenPropsType } from '../../kit'\n\nfunction CouncilInfo({\n  screenProps: { back, data, next, screenIndex, screens },\n}) {\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n      next({ ...data })\n    },\n    [data, next]\n  )\n\n  return (\n    <div>\n      <Header\n        title=\"Organization's council\"\n        subtitle=\"Read the following information attentively\"\n      />\n      <div\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        <Paragraph>\n          The council acts as the project team being funded by the fundraising\n          campaign. Council members are represented through a custom token and\n          enforce their decisions via a dedicated voting app that acts similarly\n          to a traditional multisig account. Their privileges are intentionally\n          limited to protect token holders.\n        </Paragraph>\n        <Paragraph>The council only has the ability to:</Paragraph>\n        <Paragraph>\n          <Strong>Manage council members.</Strong> The council decides on who is\n          to be included or excluded from the council.\n        </Paragraph>\n        <Paragraph>\n          <Strong>Open the presale.</Strong> The council decides on when the\n          presale‚Äîand thus the fundraising campaign‚Äîis started.\n        </Paragraph>\n        <Paragraph>\n          <Strong>Handle the fundraising's proceeds.</Strong> The fundraising\n          proceeds are periodically transferred to a Vault / Finance app\n          controlled by the council at their discretion.\n        </Paragraph>\n        <Paragraph>\n          <Strong>Open token holder votes.</Strong> The council decides on when\n          new votes should be opened for token holders to enforce decisions over\n          the organization.\n        </Paragraph>\n      </div>\n      <Navigation\n        backEnabled\n        nextEnabled\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </div>\n  )\n}\n\nCouncilInfo.propTypes = {\n  screenProps: ScreenPropsType.isRequired,\n}\n\nfunction Paragraph({ children, ...props }) {\n  const theme = useTheme()\n  return (\n    <p\n      css={`\n        color: ${theme.contentSecondary};\n        & + & {\n          margin-top: ${2 * GU}px;\n        }\n      `}\n      {...props}\n    >\n      {children}\n    </p>\n  )\n}\nParagraph.propTypes = {\n  children: PropTypes.node,\n}\n\nfunction Strong({ children, ...props }) {\n  const theme = useTheme()\n  return (\n    <span\n      css={`\n        color: ${theme.content};\n        font-weight: 800;\n      `}\n      {...props}\n    >\n      {children}\n    </span>\n  )\n}\nStrong.propTypes = {\n  children: PropTypes.string,\n}\n\nexport default CouncilInfo\n","import React, { useCallback, useReducer, useState, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Field,\n  GU,\n  Help,\n  Info,\n  TextInput,\n  textStyle,\n  useTheme,\n} from '@aragon/ui'\nimport {\n  Duration,\n  Header,\n  KnownAppBadge,\n  Navigation,\n  PercentageField,\n  ScreenPropsType,\n} from '../../kit'\n\nimport {\n  formatDuration,\n  DAY_IN_SECONDS,\n  MINUTE_IN_SECONDS,\n} from '../../kit/kit-utils'\n\nconst DEFAULT_SUPPORT = 50\nconst DEFAULT_QUORUM = 15\nconst DEFAULT_DURATION = DAY_IN_SECONDS\n\nfunction reduceFields(fields, [field, value]) {\n  if (field === 'duration') {\n    return { ...fields, duration: value }\n  }\n  if (field === 'quorum') {\n    return {\n      ...fields,\n      // 100% quorum is not possible, but any adjustments necessary should be handled in the\n      // template frontends themselves\n      quorum: value,\n      support: Math.max(fields.support, value),\n    }\n  }\n  if (field === 'support') {\n    return {\n      ...fields,\n      // 100% support is not possible, but any adjustments necessary should be handled in the\n      // template frontends themselves\n      support: value,\n      quorum: Math.min(fields.quorum, value),\n    }\n  }\n  return fields\n}\n\nfunction useFieldsLayout() {\n  // In its own hook to be adapted for smaller views\n  return `\n    display: grid;\n    grid-template-columns: auto ${12 * GU}px;\n    grid-column-gap: ${1.5 * GU}px;\n  `\n}\n\nfunction validationError(tokenName, tokenSymbol, duration) {\n  if (!tokenName.trim()) {\n    return 'Please add a token name.'\n  }\n  if (!tokenSymbol) {\n    return 'Please add a token symbol.'\n  }\n  if (duration < 10 * MINUTE_IN_SECONDS) {\n    return 'Please ensure the vote duration is equal to or longer than 10 minutes.'\n  }\n  return null\n}\n\nfunction Holders({\n  dataKey,\n  screenProps: { back, data, next, screenIndex, screens },\n  title,\n}) {\n  const screenData = (dataKey ? data[dataKey] : data) || {}\n\n  const fieldsLayout = useFieldsLayout()\n\n  const [formError, setFormError] = useState()\n  const [tokenName, setTokenName] = useState(screenData.tokenName || '')\n  const [tokenSymbol, setTokenSymbol] = useState(screenData.tokenSymbol || '')\n  const [{ support, quorum, duration }, updateField] = useReducer(\n    reduceFields,\n    {\n      support: screenData.support || DEFAULT_SUPPORT,\n      quorum: screenData.quorum || DEFAULT_QUORUM,\n      duration: screenData.duration || DEFAULT_DURATION,\n    }\n  )\n\n  const supportRef = useRef()\n  const quorumRef = useRef()\n\n  const handleSupportRef = useCallback(ref => {\n    supportRef.current = ref\n    if (ref) {\n      ref.focus()\n    }\n  }, [])\n\n  const isPercentageFieldFocused = useCallback(() => {\n    return (\n      (supportRef.current &&\n        supportRef.current.element === document.activeElement) ||\n      (quorumRef.current &&\n        quorumRef.current.element === document.activeElement)\n    )\n  }, [])\n\n  const prevNextRef = useRef()\n\n  // Focus the token name as soon as it becomes available\n  const handleTokenNameRef = useCallback(element => {\n    if (element) {\n      element.focus()\n    }\n  }, [])\n\n  const handleTokenNameChange = useCallback(event => {\n    setFormError(null)\n    setTokenName(event.target.value)\n  }, [])\n\n  const handleTokenSymbolChange = useCallback(event => {\n    setFormError(null)\n    setTokenSymbol(event.target.value.trim().toUpperCase())\n  }, [])\n\n  const disableNext = !tokenName || !tokenSymbol\n\n  const handleSupportChange = useCallback(value => {\n    setFormError(null)\n    updateField(['support', value])\n  }, [])\n\n  const handleQuorumChange = useCallback(value => {\n    setFormError(null)\n    updateField(['quorum', value])\n  }, [])\n\n  const handleDurationChange = useCallback(value => {\n    setFormError(null)\n    updateField(['duration', value])\n  }, [])\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n      const error = validationError(tokenName, tokenSymbol, duration)\n      setFormError(error)\n\n      // If one of the percentage fields is focused when the form is submitted,\n      // move the focus on the next button instead.\n      if (isPercentageFieldFocused() && prevNextRef.current) {\n        prevNextRef.current.focusNext()\n        return\n      }\n\n      if (!error) {\n        const screenData = {\n          tokenName,\n          tokenSymbol,\n          support: Math.floor(support),\n          quorum: Math.floor(quorum),\n          duration,\n        }\n        const mergedData = dataKey\n          ? { ...data, [dataKey]: screenData }\n          : { ...data, ...screenData }\n\n        next(mergedData)\n      }\n    },\n    [\n      data,\n      dataKey,\n      next,\n      tokenName,\n      tokenSymbol,\n      support,\n      quorum,\n      duration,\n      isPercentageFieldFocused,\n    ]\n  )\n\n  return (\n    <form\n      css={`\n        display: grid;\n        align-items: center;\n        justify-content: center;\n      `}\n    >\n      <Header title={title} />\n      <Subtitle\n        content={\n          <span\n            css={`\n              display: flex;\n              align-items: center;\n              justify-content: flex-start;\n              margin-bottom\n            `}\n          >\n            Choose your\n            <span\n              css={`\n                display: flex;\n                margin: 0 ${1.5 * GU}px;\n              `}\n            >\n              <KnownAppBadge\n                appName=\"token-manager.aragonpm.eth\"\n                label=\"Token: Token Holders\"\n              />\n            </span>\n            settings\n          </span>\n        }\n      />\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        These settings configure the token that will represent the organization.\n        This is the token that can be acquired through the fundraising campaign.\n      </Info>\n      <div\n        css={`\n          ${fieldsLayout};\n        `}\n      >\n        <Field\n          label={\n            <React.Fragment>\n              Organization token name\n              <Help hint=\"What is Organization Token Name?\">\n                <strong>Organization Token Name</strong> will be the name\n                assigned to the token representing the organization.{' '}\n                <em>For example: My Token.</em>\n              </Help>\n            </React.Fragment>\n          }\n        >\n          {({ id }) => (\n            <TextInput\n              ref={handleTokenNameRef}\n              id={id}\n              onChange={handleTokenNameChange}\n              placeholder=\"My Token\"\n              value={tokenName}\n              wide\n            />\n          )}\n        </Field>\n\n        <Field\n          label={\n            <React.Fragment>\n              Organization token symbol\n              <Help hint=\"What is Organization Token Symbol?\">\n                <strong>Organization Token Symbol</strong> will be the shortened\n                name (typically in capital letters) assigned to the\n                organization's token. <em>For example: TKN.</em>\n              </Help>\n            </React.Fragment>\n          }\n        >\n          {({ id }) => (\n            <TextInput\n              id={id}\n              onChange={handleTokenSymbolChange}\n              value={tokenSymbol}\n              placeholder=\"TKN\"\n              wide\n            />\n          )}\n        </Field>\n      </div>\n\n      <Subtitle\n        content={\n          <span\n            css={`\n              display: flex;\n              align-items: center;\n              justify-content: flex-start;\n              margin-bottom\n            `}\n          >\n            Choose your\n            <span\n              css={`\n                display: flex;\n                margin: 0 ${1.5 * GU}px;\n              `}\n            >\n              <KnownAppBadge\n                appName=\"voting.aragonpm.eth\"\n                label=\"Voting: Token Holders\"\n              />\n            </span>\n            settings\n          </span>\n        }\n      />\n\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        <p>\n          These settings affect the decision making process for token holders.\n        </p>\n        <p css={`margin-top: {1 * GU}px`}>\n          The support and minimum approval thresholds are strict requirements,\n          such that votes will only pass if they achieve approval percentages\n          greater than these thresholds.\n        </p>\n      </Info>\n\n      <PercentageField\n        ref={handleSupportRef}\n        label={\n          <React.Fragment>\n            Support %\n            <Help hint=\"What is Support?\">\n              <strong>Support</strong> is the relative percentage of tokens that\n              are required to vote ‚ÄúYes‚Äù for a proposal to be approved. For\n              example, if ‚ÄúSupport‚Äù is set to 50%, then more than 50% of the{' '}\n              {tokenSymbol || 'tokens'} used to vote on a proposal must vote\n              ‚ÄúYes‚Äù for it to pass.\n            </Help>\n          </React.Fragment>\n        }\n        value={support}\n        onChange={handleSupportChange}\n      />\n\n      <PercentageField\n        ref={quorumRef}\n        label={\n          <React.Fragment>\n            Minimum approval %\n            <Help hint=\"What is Minimum Approval?\">\n              <strong>Minimum Approval</strong> is the percentage of the total{' '}\n              {tokenSymbol || 'token'} supply that is required to vote ‚ÄúYes‚Äù on\n              a proposal before it can be approved. For example, if the ‚ÄúMinimum\n              Approval‚Äù is set to 20%, then more than 20% of the outstanding{' '}\n              {tokenSymbol || 'token'} supply must vote ‚ÄúYes‚Äù on a proposal for\n              it to pass.\n            </Help>\n          </React.Fragment>\n        }\n        value={quorum}\n        onChange={handleQuorumChange}\n      />\n\n      <Duration\n        duration={duration}\n        onUpdate={handleDurationChange}\n        label={\n          <React.Fragment>\n            Vote duration\n            <Help hint=\"What is Vote Duration?\">\n              <strong>Vote Duration</strong> is the length of time that token\n              holders' votes will be open for participation. For example, if the\n              Vote Duration is set to 24 hours, token holders will have 24 hours\n              to participate in the vote.\n            </Help>\n          </React.Fragment>\n        }\n      />\n      {formError && (\n        <Info\n          mode=\"error\"\n          css={`\n            margin-bottom: ${3 * GU}px;\n          `}\n        >\n          {formError}\n        </Info>\n      )}\n\n      <Navigation\n        backEnabled\n        nextEnabled={!disableNext}\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </form>\n  )\n}\n\nfunction Subtitle({ content }) {\n  const theme = useTheme()\n\n  return (\n    <h4\n      css={`\n        ${textStyle('title4')};\n        color: ${theme.contentSecondary};\n        margin-bottom: ${3 * GU}px;\n      `}\n    >\n      {content}\n    </h4>\n  )\n}\n\nSubtitle.propTypes = {\n  content: PropTypes.any,\n}\n\nfunction formatReviewFields(screenData) {\n  return [\n    [\n      'Token name & symbol',\n      `${screenData.tokenName} (${screenData.tokenSymbol})`,\n    ],\n    ['Support %', `${screenData.support}%`],\n    ['Minimum approval %', `${screenData.quorum}%`],\n    ['Vote duration', formatDuration(screenData.duration)],\n  ]\n}\n\nHolders.propTypes = {\n  dataKey: PropTypes.string,\n  screenProps: ScreenPropsType.isRequired,\n  title: PropTypes.string,\n}\n\nHolders.defaultProps = {\n  dataKey: 'holders',\n  title: 'Configure template',\n}\n\nHolders.formatReviewFields = formatReviewFields\n\nexport default Holders\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, Info, useTheme } from '@aragon/ui'\nimport { Header, Navigation, ScreenPropsType } from '../../kit'\n\nfunction HoldersInfo({\n  screenProps: { back, data, next, screenIndex, screens },\n}) {\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n      next({ ...data })\n    },\n    [data, next]\n  )\n\n  return (\n    <div>\n      <Header\n        title=\"Organization's token holders\"\n        subtitle=\"Read the following information attentively\"\n      />\n      <div\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        <Paragraph>\n          The token holders are the accounts contributing to the fundraising\n          campaign. They are represented through a custom bonded-token and a\n          voting app. They hold most of the governance rights over the\n          organization.\n        </Paragraph>\n\n        <Paragraph>Token holders can:</Paragraph>\n        <Paragraph>\n          <Strong>Buy and redeem tokens.</Strong> Token holders can buy and\n          redeem tokens through the Aragon Fundraising interface.\n        </Paragraph>\n        <Paragraph>\n          <Strong>Handle fundraising parameters.</Strong> Token holders decide\n          on how beneficiary, fees, and collateralization settings should be\n          updated. They also control the amount of funds automatically\n          transferred to the council each month.\n        </Paragraph>\n        <Paragraph>\n          <Strong>Handle organization settings.</Strong> Token holders decide on\n          which apps can be installed or upgraded and which permissions are set.\n        </Paragraph>\n      </div>\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        <p>\n          This architecture grants most of the governance rights to token\n          holders, to protect their contribution. However, this also requires\n          the organization to be able to mitigate situations where a token\n          holder could own the whole organization by owning more than 50% of the\n          shares.\n        </p>\n        <p\n          css={`\n            margin-top: ${1 * GU}px;\n          `}\n        >\n          This is why token holder votes, where most of the organization‚Äôs\n          decisions are made, can only be opened and initiated by the council.\n        </p>\n      </Info>\n      <Navigation\n        backEnabled\n        nextEnabled\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </div>\n  )\n}\n\nHoldersInfo.propTypes = {\n  screenProps: ScreenPropsType.isRequired,\n}\n\nfunction Paragraph({ children, ...props }) {\n  const theme = useTheme()\n  return (\n    <p\n      css={`\n        color: ${theme.contentSecondary};\n        & + & {\n          margin-top: ${2 * GU}px;\n        }\n      `}\n      {...props}\n    >\n      {children}\n    </p>\n  )\n}\nParagraph.propTypes = {\n  children: PropTypes.node,\n}\n\nfunction Strong({ children, ...props }) {\n  const theme = useTheme()\n  return (\n    <span\n      css={`\n        color: ${theme.content};\n        font-weight: 800;\n      `}\n      {...props}\n    >\n      {children}\n    </span>\n  )\n}\nStrong.propTypes = {\n  children: PropTypes.string,\n}\n\nexport default HoldersInfo\n","/* eslint-disable react/prop-types */\nimport React from 'react'\nimport { Decimal } from 'decimal.js'\nimport {\n  ClaimDomainScreen,\n  FundraisingScreen,\n  KnownAppBadge,\n  ReviewScreen,\n} from '../kit'\nimport Council from './components/Council'\nimport CouncilInfo from './components/CouncilInfo'\nimport Holders from './components/Holders'\nimport HoldersInfo from './components/HoldersInfo'\nimport header from './header.svg'\nimport icon from './icon.svg'\n\nfunction BN(value) {\n  return new Decimal(value)\n}\n\nconst oneDay = BN(24).mul(BN(3600))\nconst oneMonth = BN(30).mul(oneDay)\nconst oneDAI = BN(10).pow(BN(18))\nconst onePercent = BN(10).pow(BN(16))\nconst onePercentPPM = BN(10).pow(BN(4))\nconst PPM = onePercentPPM.mul(BN(100))\nconst oneBlock = BN(15)\nconst one = BN(1)\n\nfunction completeDomain(domain) {\n  return domain ? `${domain}.aragonid.eth` : ''\n}\n\nfunction adjustVotingSettings(support, quorum) {\n  // The max value for both support and quorum is 100% - 1\n  const hundredPercent = onePercent.mul(BN(100))\n\n  let adjustedSupport = onePercent.mul(BN(support))\n  if (adjustedSupport.eq(hundredPercent)) {\n    adjustedSupport = adjustedSupport.sub(one)\n  }\n\n  let adjustedQuorum = onePercent.mul(BN(quorum))\n  if (adjustedQuorum.eq(hundredPercent)) {\n    adjustedQuorum = adjustedQuorum.sub(one)\n  }\n\n  return [adjustedSupport.toFixed(0), adjustedQuorum.toFixed(0)]\n}\n\nfunction extractVotingSettings(voting) {\n  const [adjustedSupport, adjustedQuorum] = adjustVotingSettings(\n    voting.support,\n    voting.quorum\n  )\n  const duration = BN(voting.duration).toFixed(0)\n\n  return [adjustedSupport, adjustedQuorum, duration]\n}\n\nfunction extractFundraisingAppsSettings(fundraising) {\n  const goal = oneDAI.mul(BN(fundraising.targetGoal)).toFixed(0)\n  const period = oneDay.mul(BN(fundraising.fundingPeriod)).toFixed(0)\n  const exchangeRate = PPM.div(BN(fundraising.presalePrice)).toFixed(0)\n  const vestingCliffPeriod = oneDay.mul(BN(fundraising.cliffPeriod)).toFixed(0)\n  const vestingCompletePeriod = oneDay\n    .mul(BN(fundraising.vestingSchedule))\n    .toFixed(0)\n  const maximumMonthlyUpdates = onePercent\n    .mul(BN(fundraising.maximumMonthlyUpdates))\n    .toFixed(0)\n  const supplyOfferedPct = onePercentPPM\n    .mul(BN(fundraising.tokensOffered))\n    .toFixed(0)\n  const fundingForBeneficiaryPct = onePercentPPM\n    .mul(BN(fundraising.projectFunding))\n    .toFixed(0)\n\n  return {\n    goal,\n    period,\n    exchangeRate,\n    vestingCliffPeriod,\n    vestingCompletePeriod,\n    maximumMonthlyUpdates,\n    supplyOfferedPct,\n    fundingForBeneficiaryPct,\n  }\n}\n\nfunction extractCollateralizationSettings(fundraising) {\n  const cwDAI = BN(0.1)\n\n  const slippages = [\n    BN(fundraising.slippageDai)\n      .mul(onePercent)\n      .toFixed(0),\n    BN(fundraising.slippageAnt)\n      .mul(onePercent)\n      .toFixed(0),\n  ]\n  const tapRate = BN(fundraising.tapRate)\n    .mul(oneDAI)\n    .div(oneMonth)\n    .mul(oneBlock)\n    .toFixed(0)\n  const tapFloor = oneDAI.mul(BN(fundraising.tapFloor)).toFixed(0)\n\n  const xRate = one.div(BN(fundraising.presalePrice))\n  const goal = BN(fundraising.targetGoal).times(oneDAI)\n  const growth = BN(fundraising.expectedGrowth)\n  const pctOffered = BN(fundraising.tokensOffered).div(BN(100))\n  const pctBeneficiary = BN(fundraising.projectFunding).div(BN(100))\n\n  const sSupply = goal.times(xRate).div(pctOffered)\n  const sBalance = goal.times(one.minus(pctBeneficiary))\n  const sPrice = BN(fundraising.initialPricePerToken)\n  const sMarketCap = sSupply.times(sPrice)\n\n  const eMarketCap = sMarketCap.times(growth)\n  const ePrice = sPrice.times(growth.squareRoot())\n\n  const ppSupplyDAI = ePrice\n    .div(eMarketCap.pow(one.minus(cwDAI)).times(sPrice.pow(cwDAI)))\n    .pow(one.div(cwDAI.minus(one)))\n  const vSupplyDAI = ppSupplyDAI.minus(sSupply)\n\n  const ppBalanceDAI = sPrice.times(ppSupplyDAI).times(cwDAI)\n  const vBalanceDAI = ppBalanceDAI.minus(sBalance)\n\n  const virtualSupplies = [vSupplyDAI.toFixed(0), vSupplyDAI.toFixed(0)]\n  const virtualBalances = [\n    vBalanceDAI.toFixed(0),\n    vBalanceDAI.div(BN(10)).toFixed(0),\n  ]\n\n  return {\n    virtualSupplies,\n    virtualBalances,\n    slippages,\n    tapRate,\n    tapFloor,\n  }\n}\n\nexport default {\n  id: 'fundraising-multisig-template.aragonpm.eth',\n  name: 'Fundraising',\n  beta: true,\n  header,\n  icon,\n  description: `\n    Launch a transparent and accountable crowdfunding campaign for your\n    organization.\n  `,\n  userGuideUrl: 'https://fundraising.aragon.black/',\n  sourceCodeUrl: 'https://github.com/AragonBlack/fundraising',\n  registry: 'aragonpm.eth',\n  apps: [\n    {\n      appName: 'aragon-fundraising.aragonpm.eth',\n      label: 'Fundraising',\n    },\n    { appName: 'agent.aragonpm.eth', label: 'Agent: Reserve Pool' },\n    { appName: 'voting.aragonpm.eth', label: 'Voting: Council' },\n    { appName: 'token-manager.aragonpm.eth', label: 'Tokens: Council' },\n    { appName: 'voting.aragonpm.eth', label: 'Voting: Token Holder' },\n    { appName: 'token-manager.aragonpm.eth', label: 'Tokens: Token Holder' },\n    { appName: 'finance.aragonpm.eth', label: 'Finance' },\n  ],\n  optionalApps: [],\n  screens: [\n    [\n      data => completeDomain(data.domain) || 'Claim domain',\n      props => <ClaimDomainScreen screenProps={props} />,\n    ],\n    ['Configure council', props => <CouncilInfo screenProps={props} />],\n    [\n      'Configure council',\n      props => (\n        <Council\n          dataKey=\"council\"\n          screenProps={props}\n          title=\"Configure council\"\n        />\n      ),\n    ],\n    ['Configure token holders', props => <HoldersInfo screenProps={props} />],\n    [\n      'Configure token holders',\n      props => (\n        <Holders\n          dataKey=\"holders\"\n          screenProps={props}\n          title=\"Configure token holders\"\n        />\n      ),\n    ],\n    [\n      'Configure fundraising',\n      props => <FundraisingScreen screenProps={props} />,\n    ],\n    [\n      'Review information',\n      props => {\n        const { domain, council, holders, fundraising } = props.data\n        return (\n          <ReviewScreen\n            screenProps={props}\n            items={[\n              {\n                label: 'General info',\n                fields: [\n                  ['Organization template', 'Fundraising'],\n                  ['Name', completeDomain(domain)],\n                ],\n              },\n              {\n                label: 'Council',\n                fields: Council.formatReviewFields(council),\n              },\n              {\n                label: 'Token Holders',\n                fields: Holders.formatReviewFields(holders),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"aragon-fundraising.aragonpm.eth\"\n                    label=\"Fundraising\"\n                  />\n                ),\n                fields: FundraisingScreen.formatReviewFields(fundraising),\n              },\n            ]}\n          />\n        )\n      },\n    ],\n  ],\n  prepareTransactions(createTx, data) {\n    const financePeriod = 0 // default\n    const openDate = 0 // default\n\n    const { domain, council, holders, fundraising } = data\n\n    const councilMembers = council.members\n    const councilVotingSettings = extractVotingSettings(council)\n    const holdersVotingSettings = extractVotingSettings(holders)\n    const {\n      goal,\n      period,\n      exchangeRate,\n      vestingCliffPeriod,\n      vestingCompletePeriod,\n      maximumMonthlyUpdates,\n      supplyOfferedPct,\n      fundingForBeneficiaryPct,\n    } = extractFundraisingAppsSettings(fundraising)\n    const {\n      virtualSupplies,\n      virtualBalances,\n      slippages,\n      tapRate,\n      tapFloor,\n    } = extractCollateralizationSettings(fundraising)\n\n    return [\n      {\n        name: 'Prepare organization',\n        transaction: createTx('prepareInstance', [\n          council.tokenName,\n          council.tokenSymbol,\n          councilMembers,\n          councilVotingSettings,\n          financePeriod,\n        ]),\n      },\n      {\n        name: 'Install Token Holder apps',\n        // Note that we need to keep this usage of \"share\"\n        // as the template contract only exposes \"installShareApps()\"\n        transaction: createTx('installShareApps', [\n          holders.tokenName,\n          holders.tokenSymbol,\n          holdersVotingSettings,\n        ]),\n      },\n      {\n        name: 'Install Fundraising',\n        transaction: createTx('installFundraisingApps', [\n          goal,\n          period,\n          exchangeRate,\n          vestingCliffPeriod,\n          vestingCompletePeriod,\n          supplyOfferedPct,\n          fundingForBeneficiaryPct,\n          openDate,\n          fundraising.batchLength,\n          maximumMonthlyUpdates,\n          maximumMonthlyUpdates,\n        ]),\n      },\n      {\n        name: 'Finalize organization',\n        transaction: createTx('finalizeInstance', [\n          domain,\n          virtualSupplies,\n          virtualBalances,\n          slippages,\n          tapRate,\n          tapFloor,\n        ]),\n      },\n    ]\n  },\n}\n","/* eslint-disable react/prop-types */\nimport React from 'react'\nimport BN from 'bn.js'\nimport {\n  ClaimDomainScreen,\n  KnownAppBadge,\n  ReviewScreen,\n  TokensScreen,\n  VotingScreen,\n} from '../kit'\n\nimport header from './header.svg'\nimport icon from './icon.svg'\n\nfunction completeDomain(domain) {\n  return domain ? `${domain}.aragonid.eth` : ''\n}\n\nfunction adjustVotingSettings(support, quorum) {\n  // The max value for both support and quorum is 100% - 1\n  const onePercent = new BN(10).pow(new BN(16))\n  const hundredPercent = onePercent.mul(new BN(100))\n\n  let adjustedSupport = onePercent.mul(new BN(support))\n  if (adjustedSupport.eq(hundredPercent)) {\n    adjustedSupport = adjustedSupport.sub(new BN(1))\n  }\n\n  let adjustedQuorum = onePercent.mul(new BN(quorum))\n  if (adjustedQuorum.eq(hundredPercent)) {\n    adjustedQuorum = adjustedQuorum.sub(new BN(1))\n  }\n\n  return [adjustedSupport.toString(), adjustedQuorum.toString()]\n}\n\nexport default {\n  id: 'membership-template.aragonpm.eth',\n  name: 'Membership',\n  header,\n  icon,\n  description: `\n    Use a non-transferable token to represent membership. Decisions are\n    made based on one-member-one-vote governance.\n  `,\n  userGuideUrl:\n    'https://help.aragon.org/article/34-create-a-new-membership-organization',\n  sourceCodeUrl:\n    'https://github.com/aragon/dao-templates/tree/templates-membership-v1.0.0/templates/membership',\n  registry: 'aragonpm.eth',\n  apps: [\n    { appName: 'voting.aragonpm.eth', label: 'Voting' },\n    { appName: 'token-manager.aragonpm.eth', label: 'Tokens' },\n    { appName: 'finance.aragonpm.eth', label: 'Finance' },\n  ],\n  optionalApps: [{ appName: 'agent.aragonpm.eth', label: 'Agent' }],\n  screens: [\n    [\n      data => completeDomain(data.domain) || 'Claim domain',\n      props => <ClaimDomainScreen screenProps={props} />,\n    ],\n    ['Configure template', props => <VotingScreen screenProps={props} />],\n    [\n      'Configure template',\n      props => <TokensScreen screenProps={props} accountStake={1} />,\n    ],\n    [\n      'Review information',\n      props => {\n        const { domain, voting, tokens } = props.data\n        return (\n          <ReviewScreen\n            screenProps={props}\n            items={[\n              {\n                label: 'General info',\n                fields: [\n                  ['Organization template', 'Membership'],\n                  ['Name', completeDomain(domain)],\n                ],\n              },\n              {\n                label: (\n                  <KnownAppBadge appName=\"voting.aragonpm.eth\" label=\"Voting\" />\n                ),\n                fields: VotingScreen.formatReviewFields(voting),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"token-manager.aragonpm.eth\"\n                    label=\"Tokens\"\n                  />\n                ),\n                fields: TokensScreen.formatReviewFields(tokens),\n              },\n            ]}\n          />\n        )\n      },\n    ],\n  ],\n  prepareTransactions(createTx, data, networkType) {\n    const financePeriod = 0 // default\n    const hasPayroll = false\n\n    const { domain, optionalApps = [], tokens, voting } = data\n    const useAgentAsVault = optionalApps.includes('agent.aragonpm.eth')\n\n    const { tokenName, tokenSymbol, members } = tokens\n    const accounts = members.map(([account]) => account)\n\n    const { support, quorum, duration } = voting\n    const [adjustedSupport, adjustedQuorum] = adjustVotingSettings(\n      support,\n      quorum\n    )\n    const adjustedDuration = new BN(duration).toString()\n    const votingSettings = [adjustedSupport, adjustedQuorum, adjustedDuration]\n\n    // Rinkeby has its gas limit capped at 7M, so some larger 6.5M+ transactions are\n    // often not mined\n    const forceMultipleTransactions =\n      networkType === 'rinkeby' && members.length > 1\n\n    if (!hasPayroll && !forceMultipleTransactions) {\n      return [\n        {\n          name: 'Create organization',\n          transaction: createTx('newTokenAndInstance', [\n            tokenName,\n            tokenSymbol,\n            domain,\n            accounts,\n            votingSettings,\n            financePeriod,\n            useAgentAsVault,\n          ]),\n        },\n      ]\n    }\n\n    return [\n      {\n        name: 'Create token',\n        transaction: createTx('newToken', [tokenName, tokenSymbol]),\n      },\n      {\n        name: 'Create organization',\n        transaction: createTx('newInstance', [\n          domain,\n          accounts,\n          votingSettings,\n          financePeriod,\n          useAgentAsVault,\n        ]),\n      },\n    ]\n  },\n}\n","import React from 'react'\nimport BN from 'bn.js'\nimport {\n  ClaimDomainScreen,\n  DotVotingScreen,\n  KnownAppBadge,\n  ReviewScreen,\n  TokensScreen,\n  VotingScreen,\n} from '../kit'\n\nimport header from './header.svg'\nimport icon from './icon.svg'\n\nconst ONE_PERCENT = new BN(10).pow(new BN(16))\n\nfunction completeDomain(domain) {\n  return domain ? `${domain}.aragonid.eth` : ''\n}\n\nfunction adjustVotingSettings(support, quorum) {\n  // The max value for both support and quorum is 100% - 1\n  const hundredPercent = ONE_PERCENT.mul(new BN(100))\n\n  let adjustedSupport = ONE_PERCENT.mul(new BN(support))\n  if (adjustedSupport.eq(hundredPercent)) {\n    adjustedSupport = adjustedSupport.sub(new BN(1))\n  }\n\n  let adjustedQuorum = ONE_PERCENT.mul(new BN(quorum))\n  if (adjustedQuorum.eq(hundredPercent)) {\n    adjustedQuorum = adjustedQuorum.sub(new BN(1))\n  }\n\n  return [adjustedSupport.toString(), adjustedQuorum.toString()]\n}\n\nfunction adjustDotVotingSettings(dvSupport, dvQuorum) {\n  const adjustedDvSupport = ONE_PERCENT.mul(new BN(dvSupport))\n\n  // The min value for quorum must be 1 or greater\n  const adjustedDvQuorum = new BN(dvQuorum).isZero()\n    ? new BN(1)\n    : ONE_PERCENT.mul(new BN(dvQuorum))\n\n  return [adjustedDvSupport.toString(), adjustedDvQuorum.toString()]\n}\n\nexport default {\n  id: 'open-enterprise-template.aragonpm.eth',\n  name: 'Open Enterprise',\n  header,\n  icon,\n  description: `\n    A suite of apps for organizations, including project management,\n    bounties, budget planning and rewards.\n  `,\n  userGuideUrl: 'https://autark.gitbook.io/open-enterprise/',\n  sourceCodeUrl: 'https://github.com/AutarkLabs/open-enterprise',\n  registry: 'aragonpm.eth',\n  apps: [\n    { appName: 'voting.aragonpm.eth', label: 'Voting' },\n    { appName: 'token-manager.aragonpm.eth', label: 'Tokens' },\n    { appName: 'finance.aragonpm.eth', label: 'Finance' },\n    { appName: 'address-book.aragonpm.eth', label: 'Address Book' },\n    { appName: 'allocations.aragonpm.eth', label: 'Allocations' },\n    { appName: 'dot-voting.aragonpm.eth', label: 'Dot Voting' },\n    { appName: 'projects.aragonpm.eth', label: 'Projects' },\n    { appName: 'rewards.aragonpm.eth', label: 'Rewards' },\n  ],\n  screens: [\n    [\n      data => completeDomain(data.domain) || 'Claim domain',\n      props => <ClaimDomainScreen screenProps={props} />,\n    ],\n    ['Configure template', props => <VotingScreen screenProps={props} />],\n    ['Configure template', props => <DotVotingScreen screenProps={props} />],\n    ['Configure template', props => <TokensScreen screenProps={props} />],\n    [\n      'Review information',\n      props => {\n        const { domain, dotVoting, tokens, voting } = props.data\n        return (\n          <ReviewScreen\n            screenProps={props}\n            items={[\n              {\n                label: 'General info',\n                fields: [\n                  ['Organization template', 'Open Enterprise'],\n                  ['Name', completeDomain(domain)],\n                ],\n              },\n              {\n                label: (\n                  <KnownAppBadge appName=\"voting.aragonpm.eth\" label=\"Voting\" />\n                ),\n                fields: VotingScreen.formatReviewFields(voting),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"dot-voting.aragonpm.eth\"\n                    label=\"Dot Voting\"\n                  />\n                ),\n                fields: DotVotingScreen.formatReviewFields(dotVoting),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"token-manager.aragonpm.eth\"\n                    label=\"Tokens\"\n                  />\n                ),\n                fields: TokensScreen.formatReviewFields(tokens),\n              },\n            ]}\n          />\n        )\n      },\n    ],\n  ],\n  prepareTransactions(createTx, data) {\n    const allocationsPeriod = 0 // default\n    const financePeriod = 0 // default\n\n    const { domain, dotVoting, tokens, voting } = data\n    const { tokenName, tokenSymbol, members } = tokens\n\n    const baseStake = new BN(10).pow(new BN(18))\n    const stakes = members.map(([_, stake]) =>\n      baseStake.mul(new BN(stake.toString())).toString()\n    )\n    const accounts = members.map(([account]) => account)\n\n    const { support, quorum, duration } = voting\n    const [adjustedSupport, adjustedQuorum] = adjustVotingSettings(\n      support,\n      quorum\n    )\n    const adjustedDuration = new BN(duration).toString()\n    const votingSettings = [adjustedSupport, adjustedQuorum, adjustedDuration]\n\n    const {\n      support: dvSupport,\n      quorum: dvQuorum,\n      duration: dvDuration,\n    } = dotVoting\n    const [adjustedDvSupport, adjustedDvQuorum] = adjustDotVotingSettings(\n      dvSupport,\n      dvQuorum\n    )\n    const adjustedDvDuration = new BN(dvDuration).toString()\n    const dotVotingSettings = [\n      adjustedDvQuorum,\n      adjustedDvSupport,\n      adjustedDvDuration,\n    ]\n\n    /* For Open Enterprise, is currently not possible to use a single tx, the creation process cost is ~10M gas */\n    return [\n      {\n        name: 'Create organization',\n        transaction: createTx('newTokenAndInstance', [\n          tokenName,\n          tokenSymbol,\n          domain,\n          accounts,\n          stakes,\n          votingSettings,\n          financePeriod,\n        ]),\n      },\n      {\n        name: 'Install Open Enterprise',\n        transaction: createTx('newOpenEnterprise', [\n          dotVotingSettings,\n          allocationsPeriod,\n          false, // useDiscussions option, will revisit when forwarding API gets ready\n        ]),\n      },\n    ]\n  },\n}\n","/* eslint-disable react/prop-types */\nimport React from 'react'\nimport BN from 'bn.js'\nimport {\n  ClaimDomainScreen,\n  KnownAppBadge,\n  ReviewScreen,\n  TokensScreen,\n  VotingScreen,\n} from '../kit'\n\nimport header from './header.svg'\nimport icon from './icon.svg'\n\nfunction completeDomain(domain) {\n  return domain ? `${domain}.aragonid.eth` : ''\n}\n\nfunction adjustVotingSettings(support, quorum) {\n  // The max value for both support and quorum is 100% - 1\n  const onePercent = new BN(10).pow(new BN(16))\n  const hundredPercent = onePercent.mul(new BN(100))\n\n  let adjustedSupport = onePercent.mul(new BN(support))\n  if (adjustedSupport.eq(hundredPercent)) {\n    adjustedSupport = adjustedSupport.sub(new BN(1))\n  }\n\n  let adjustedQuorum = onePercent.mul(new BN(quorum))\n  if (adjustedQuorum.eq(hundredPercent)) {\n    adjustedQuorum = adjustedQuorum.sub(new BN(1))\n  }\n\n  return [adjustedSupport.toString(), adjustedQuorum.toString()]\n}\n\nexport default {\n  id: 'reputation-template.aragonpm.eth',\n  name: 'Reputation',\n  header,\n  icon,\n  description: `\n    Use non-transferable tokens to represent reputation. Decisions are made\n    using reputation-weighted voting.\n  `,\n  userGuideUrl:\n    'https://help.aragon.org/article/32-create-a-new-reputation-organization',\n  sourceCodeUrl:\n    'https://github.com/aragon/dao-templates/tree/templates-reputation-v1.0.0/templates/reputation',\n  registry: 'aragonpm.eth',\n  apps: [\n    { appName: 'voting.aragonpm.eth', label: 'Voting' },\n    { appName: 'token-manager.aragonpm.eth', label: 'Tokens' },\n    { appName: 'finance.aragonpm.eth', label: 'Finance' },\n  ],\n  optionalApps: [{ appName: 'agent.aragonpm.eth', label: 'Agent' }],\n  screens: [\n    [\n      data => completeDomain(data.domain) || 'Claim domain',\n      props => <ClaimDomainScreen screenProps={props} />,\n    ],\n    ['Configure template', props => <VotingScreen screenProps={props} />],\n    ['Configure template', props => <TokensScreen screenProps={props} />],\n    [\n      'Review information',\n      props => {\n        const { domain, voting, tokens } = props.data\n        return (\n          <ReviewScreen\n            screenProps={props}\n            items={[\n              {\n                label: 'General info',\n                fields: [\n                  ['Organization template', 'Reputation'],\n                  ['Name', completeDomain(domain)],\n                ],\n              },\n              {\n                label: (\n                  <KnownAppBadge appName=\"voting.aragonpm.eth\" label=\"Voting\" />\n                ),\n                fields: VotingScreen.formatReviewFields(voting),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"token-manager.aragonpm.eth\"\n                    label=\"Tokens\"\n                  />\n                ),\n                fields: TokensScreen.formatReviewFields(tokens),\n              },\n            ]}\n          />\n        )\n      },\n    ],\n  ],\n  prepareTransactions(createTx, data, networkType) {\n    const financePeriod = 0 // default\n    const hasPayroll = false\n\n    const { domain, optionalApps = [], tokens, voting } = data\n    const useAgentAsVault = optionalApps.includes('agent.aragonpm.eth')\n\n    const { tokenName, tokenSymbol, members } = tokens\n    const baseStake = new BN(10).pow(new BN(18))\n    const stakes = members.map(([_, stake]) =>\n      baseStake.mul(new BN(stake.toString())).toString()\n    )\n    const accounts = members.map(([account]) => account)\n\n    const { support, quorum, duration } = voting\n    const [adjustedSupport, adjustedQuorum] = adjustVotingSettings(\n      support,\n      quorum\n    )\n    const adjustedDuration = new BN(duration).toString()\n    const votingSettings = [adjustedSupport, adjustedQuorum, adjustedDuration]\n\n    // Rinkeby has its gas limit capped at 7M, so some larger 6.5M+ transactions are\n    // often not mined\n    const forceMultipleTransactions =\n      networkType === 'rinkeby' && members.length > 1\n\n    if (!hasPayroll && !forceMultipleTransactions) {\n      return [\n        {\n          name: 'Create organization',\n          transaction: createTx('newTokenAndInstance', [\n            tokenName,\n            tokenSymbol,\n            domain,\n            accounts,\n            stakes,\n            votingSettings,\n            financePeriod,\n            useAgentAsVault,\n          ]),\n        },\n      ]\n    }\n\n    return [\n      {\n        name: 'Create token',\n        transaction: createTx('newToken', [tokenName, tokenSymbol]),\n      },\n      {\n        name: 'Create organization',\n        transaction: createTx('newInstance', [\n          domain,\n          accounts,\n          stakes,\n          votingSettings,\n          financePeriod,\n          useAgentAsVault,\n        ]),\n      },\n    ]\n  },\n}\n","import React, { useCallback, useReducer, useState, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, Help, Info } from '@aragon/ui'\nimport {\n  Header,\n  PercentageField,\n  Navigation,\n  ScreenPropsType,\n  Duration,\n} from '../../../kit'\nimport {\n  formatDuration,\n  DAY_IN_SECONDS,\n  HOUR_IN_SECONDS,\n  MINUTE_IN_SECONDS,\n} from '../../../kit/kit-utils'\n\nconst DEFAULT_SUPPORT = 50\nconst DEFAULT_QUORUM = 1\nconst DEFAULT_DURATION = DAY_IN_SECONDS\nconst DEFAULT_BUFFER = HOUR_IN_SECONDS\nconst DEFAULT_DELAY = DAY_IN_SECONDS\n\nfunction validationError(duration) {\n  if (duration < 1 * MINUTE_IN_SECONDS) {\n    return 'Please ensure the vote duration is equal to or longer than 1 minute.'\n  }\n  return null\n}\n\nfunction reduceFields(fields, [field, value]) {\n  if (field === 'duration') {\n    return { ...fields, duration: value }\n  }\n  if (field === 'buffer') {\n    return { ...fields, buffer: value }\n  }\n  if (field === 'delay') {\n    return { ...fields, delay: value }\n  }\n  if (field === 'quorum') {\n    return {\n      ...fields,\n      quorum: value,\n      support: Math.max(fields.support, value),\n    }\n  }\n  if (field === 'support') {\n    return {\n      ...fields,\n      support: value,\n      quorum: Math.min(fields.quorum, value),\n    }\n  }\n  return fields\n}\n\nfunction DandelionVotingScreen({\n  dataKey,\n  screenProps: { back, data, next, screenIndex, screens },\n}) {\n  const screenData = (dataKey ? data[dataKey] : data) || {}\n\n  const [formError, setFormError] = useState(null)\n\n  const [\n    { support, quorum, duration, buffer, delay },\n    updateField,\n  ] = useReducer(reduceFields, {\n    support: screenData.support || DEFAULT_SUPPORT,\n    quorum: screenData.quorum || DEFAULT_QUORUM,\n    duration: screenData.duration || DEFAULT_DURATION,\n    buffer: screenData.buffer || DEFAULT_BUFFER,\n    delay: screenData.delay || DEFAULT_DELAY,\n  })\n\n  const handleSupportChange = useCallback(value => {\n    setFormError(null)\n    updateField(['support', value])\n  }, [])\n\n  const handleQuorumChange = useCallback(value => {\n    setFormError(null)\n    updateField(['quorum', value])\n  }, [])\n\n  const handleDurationChange = useCallback(value => {\n    setFormError(null)\n    updateField(['duration', value])\n  }, [])\n\n  const handleBufferChange = useCallback(value => {\n    setFormError(null)\n    updateField(['buffer', value])\n  }, [])\n\n  const handleDelayChange = useCallback(value => {\n    setFormError(null)\n    updateField(['delay', value])\n  }, [])\n\n  const supportRef = useRef()\n  const quorumRef = useRef()\n\n  const handleSupportRef = useCallback(ref => {\n    supportRef.current = ref\n    if (ref) {\n      ref.focus()\n    }\n  }, [])\n\n  const isPercentageFieldFocused = useCallback(() => {\n    return (\n      (supportRef.current &&\n        supportRef.current.element === document.activeElement) ||\n      (quorumRef.current &&\n        quorumRef.current.element === document.activeElement)\n    )\n  }, [])\n\n  const prevNextRef = useRef()\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n      const error = validationError(duration)\n      setFormError(error)\n\n      // If one of the percentage fields is focused when the form is submitted,\n      // move the focus on the next button instead.\n      if (isPercentageFieldFocused() && prevNextRef.current) {\n        prevNextRef.current.focusNext()\n        return\n      }\n\n      if (!error) {\n        const screenData = {\n          support: Math.floor(support),\n          quorum: Math.floor(quorum),\n          duration,\n          buffer,\n          delay,\n        }\n        next(dataKey ? { ...data, [dataKey]: screenData } : screenData)\n      }\n    },\n    [\n      duration,\n      isPercentageFieldFocused,\n      support,\n      quorum,\n      buffer,\n      delay,\n      next,\n      dataKey,\n      data,\n    ]\n  )\n\n  return (\n    <form\n      css={`\n        display: grid;\n        align-items: center;\n        justify-content: center;\n      `}\n    >\n      <Header\n        title=\"Configure template\"\n        subtitle=\"Choose your Voting app settings below.\"\n      />\n\n      <PercentageField\n        ref={handleSupportRef}\n        label={\n          <React.Fragment>\n            Support %\n            <Help hint=\"What is Support?\">\n              <strong>Support</strong> is the relative percentage of tokens that\n              are required to vote ‚ÄúYes‚Äù for a proposal to be approved. For\n              example, if ‚ÄúSupport‚Äù is set to 50%, then more than 50% of the\n              tokens used to vote on a proposal must vote ‚ÄúYes‚Äù for it to pass.\n            </Help>\n          </React.Fragment>\n        }\n        value={support}\n        onChange={handleSupportChange}\n      />\n\n      <PercentageField\n        ref={quorumRef}\n        label={\n          <React.Fragment>\n            Minimum approval %\n            <Help hint=\"What is Minimum Approval?\">\n              <strong>Minimum Approval</strong> is the percentage of the total\n              token supply that is required to vote ‚ÄúYes‚Äù on a proposal before\n              it can be approved. For example, if the ‚ÄúMinimum Approval‚Äù is set\n              to 20%, then more than 20% of the outstanding token supply must\n              vote ‚ÄúYes‚Äù on a proposal for it to pass.\n            </Help>\n          </React.Fragment>\n        }\n        value={quorum}\n        onChange={handleQuorumChange}\n      />\n\n      <Duration\n        duration={duration}\n        onUpdate={handleDurationChange}\n        label={\n          <React.Fragment>\n            Vote duration\n            <Help hint=\"What is Vote Duration?\">\n              <strong>Vote Duration</strong> is the length of time that the vote\n              will be open for participation. For example, if the Vote Duration\n              is set to 24 hours, then tokenholders have 24 hours to participate\n              in the vote.`\n            </Help>\n          </React.Fragment>\n        }\n      />\n      <Duration\n        duration={buffer}\n        onUpdate={handleBufferChange}\n        label={\n          <React.Fragment>\n            Vote buffer\n            <Help hint=\"What is Vote Buffer?\">\n              <strong>Vote Buffer</strong> is the minimum amount of time\n              separating the start time of each new vote, as votes are processed\n              in the sequence they were created.\n            </Help>\n          </React.Fragment>\n        }\n      />\n      <Duration\n        duration={delay}\n        onUpdate={handleDelayChange}\n        label={\n          <React.Fragment>\n            Vote delay\n            <Help hint=\"What is Vote Delay?\">\n              <strong>Vote Delay</strong> is the period of time an approved vote\n              must wait before being executed.\n            </Help>\n          </React.Fragment>\n        }\n      />\n\n      {formError && (\n        <Info\n          mode=\"error\"\n          css={`\n            margin-bottom: ${3 * GU}px;\n          `}\n        >\n          {formError}\n        </Info>\n      )}\n\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        The support and minimum approval thresholds are strict requirements,\n        such that votes will only pass if they achieve approval percentages\n        greater than these thresholds.\n      </Info>\n\n      <Navigation\n        ref={prevNextRef}\n        backEnabled\n        nextEnabled\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </form>\n  )\n}\n\nDandelionVotingScreen.propTypes = {\n  dataKey: PropTypes.string,\n  screenProps: ScreenPropsType.isRequired,\n}\n\nDandelionVotingScreen.defaultProps = {\n  appLabel: 'Voting',\n  dataKey: 'voting',\n  title: 'Configure template',\n}\n\nfunction formatReviewFields(screenData) {\n  return [\n    ['Support', `${screenData.support}%`],\n    ['Minimum approval %', `${screenData.quorum}%`],\n    ['Vote duration', formatDuration(screenData.duration)],\n    ['Vote buffer', formatDuration(screenData.buffer)],\n    ['Vote delay', formatDuration(screenData.delay)],\n  ]\n}\n\nDandelionVotingScreen.formatReviewFields = formatReviewFields\nexport default DandelionVotingScreen\n","import { chains } from 'use-wallet'\nimport { getDaiTokenAddress, getChainId } from '../../../../util/network'\n\nexport const TOKEN_FAKE_ADDRESS = '0x0000000000000000000000000000000000000000'\n\nconst getDaiToken = networkType => ({\n  symbol: 'DAI',\n  name: 'Dai Stablecoin',\n  address: getDaiTokenAddress(networkType),\n})\n\nconst getNativeCurrency = networkType => {\n  const chainId = getChainId(networkType)\n  const symbol = chains.getChainInformation(chainId)?.nativeCurrency.symbol\n  return {\n    symbol,\n    address: TOKEN_FAKE_ADDRESS,\n  }\n}\n\nexport function getDefaultRedeemableTokens(networkType) {\n  return [getNativeCurrency(networkType), getDaiToken(networkType)]\n}\n\nexport function getDefaultAcceptedTokens(networkType) {\n  return [getNativeCurrency(networkType), getDaiToken(networkType)]\n}\n\nexport function getDefaultLockTokenByNetwork(networkType) {\n  return getDaiToken(networkType)\n}\n","import React, { useMemo } from 'react'\nimport styled from 'styled-components'\nimport { addressesEqual, GU, tokenIconUrl } from '@aragon/ui'\nimport { shortenAddress } from '../../../../util/web3'\nimport { TOKEN_FAKE_ADDRESS } from '../../config/helpers/tokens'\n\n/* eslint-disable react/prop-types */\nconst TokenSelectorInstance = React.memo(function TokenSelectorInstance({\n  address,\n  name,\n  symbol,\n  showIcon = true,\n}) {\n  const hasDescription = useMemo(() => {\n    return name || !addressesEqual(address, TOKEN_FAKE_ADDRESS)\n  }, [name, address])\n\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n      `}\n    >\n      {/* TODO: Set network type when available  */}\n      {showIcon ? (\n        <Icon src={tokenIconUrl(address)} />\n      ) : (\n        <div\n          css={`\n            width: ${3 * GU}px;\n          `}\n        />\n      )}\n      {symbol && (\n        <span\n          css={`\n            margin-right: ${1 * GU}px;\n          `}\n        >\n          {symbol}\n        </span>\n      )}\n      <div>\n        {hasDescription && <>(</>}\n        {name && (\n          <span\n            css={`\n              max-width: 110px;\n              overflow: hidden;\n              text-overflow: ellipsis;\n            `}\n          >\n            {name}\n          </span>\n        )}\n        {!addressesEqual(address, TOKEN_FAKE_ADDRESS) && (\n          <span\n            css={`\n              margin-left: ${1 * GU}px;\n            `}\n          >\n            {shortenAddress(address)}\n          </span>\n        )}\n        {hasDescription && <>)</>}\n      </div>\n    </div>\n  )\n})\n\nconst Icon = styled.img.attrs({ alt: '', width: '16', height: '16' })`\n  margin-right: ${1 * GU}px;\n`\n\nexport default TokenSelectorInstance\n","import React, { useCallback, useMemo, useState } from 'react'\nimport { DropDown, Field, TextInput, GU } from '@aragon/ui'\n\nimport TokenSelectorInstance from './TokenSelectorInstance'\n\n/* eslint-disable react/prop-types */\nfunction TokenSelector({\n  componentIndex,\n  onChange,\n  selectedIndex,\n  showCustomMode,\n  tokens,\n  value,\n}) {\n  const [customToken, setCustomToken] = useState({\n    address: selectedIndex === 0 ? value : '',\n  })\n\n  const showCustomToken = selectedIndex === 0\n  const showCustomHorizontal = showCustomMode === 'horizontal'\n  const dropdownWidth = showCustomToken && showCustomHorizontal ? '30%' : '100%'\n\n  const getTokenByIndex = useCallback(\n    index => {\n      if (index === 0) {\n        return customToken\n      }\n\n      // Adjust for custom address\n      return tokens[index - 1]\n    },\n    [customToken, tokens]\n  )\n\n  const handleChange = useCallback(\n    index => {\n      const token = getTokenByIndex(index)\n      onChange({\n        token,\n        selectedIndex: index,\n        componentIndex,\n      })\n    },\n    [componentIndex, getTokenByIndex, onChange]\n  )\n\n  const handleCustomTokenChange = useCallback(\n    event => {\n      const { value } = event.target\n\n      setCustomToken(value)\n      onChange({\n        token: { address: value },\n        selectedIndex: 0,\n        componentIndex,\n      })\n    },\n    [componentIndex, onChange]\n  )\n\n  const items = useMemo(\n    () => [\n      'Other',\n      ...tokens.map(({ address, name, symbol, verified }) => (\n        <TokenSelectorInstance\n          address={address}\n          name={name}\n          showIcon={verified}\n          symbol={symbol}\n        />\n      )),\n    ],\n    [tokens]\n  )\n\n  return (\n    <div\n      css={`\n        display: ${showCustomHorizontal ? 'flex' : 'block'};\n        align-items: flex-end;\n        width 100%;\n      `}\n    >\n      <DropDown\n        header=\"Token\"\n        placeholder=\"Select a token\"\n        items={items}\n        selected={selectedIndex}\n        onChange={handleChange}\n        width={dropdownWidth}\n        required\n        css={`\n          margin-bottom: ${showCustomHorizontal ? '0' : `${1.5 * GU}px`};\n          margin-right: ${showCustomToken || componentIndex !== 0\n            ? `${1 * GU}px`\n            : '0'};\n          min-width: 150px;\n        `}\n      />\n\n      {showCustomToken && (\n        <Field\n          label={'Select custom token'}\n          css={`\n            margin: 0;\n            width: 100%;\n            margin-right: ${componentIndex !== 0 ? `${1 * GU}px` : '0'};\n          `}\n        >\n          <TextInput\n            placeholder=\"SYM‚Ä¶\"\n            value={customToken.address}\n            onChange={handleCustomTokenChange}\n            required\n            wide\n          />\n        </Field>\n      )}\n    </div>\n  )\n}\n\nTokenSelector.defaultProps = {\n  onChange: () => {},\n  tokens: [],\n  label: 'Token',\n  labelCustomToken: 'Token address or symbol',\n  selectedIndex: -1,\n  showCustomMode: 'vertical',\n}\n\nexport default TokenSelector\n","import React, { useCallback, useState, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { Field, GU, Help, Info, TextInput, isAddress } from '@aragon/ui'\nimport {\n  Header,\n  Navigation,\n  ScreenPropsType,\n  Duration,\n  KnownAppBadge,\n} from '../../../kit'\nimport TokenSelector from '../../components/TokenSelector/TokenSelector'\nimport { getDefaultLockTokenByNetwork } from '../helpers/tokens'\nimport { shortenAddress } from '../../../../util/web3'\nimport {\n  formatDuration,\n  DAY_IN_SECONDS,\n  MINUTE_IN_SECONDS,\n} from '../../../kit/kit-utils'\nimport { useWallet } from '../../../../contexts/wallet'\n\nconst DEFAULT_SPAM_PENALTY = 50\nconst DEFAULT_DURATION = DAY_IN_SECONDS\nconst EMPTY_TOKEN = { data: { address: '' }, selectedIndex: -1 }\n\nfunction validationError(lockAmount, lockDuration, lockToken) {\n  if (!lockToken || !isAddress(lockToken)) {\n    return 'You need at least one valid address.'\n  }\n  if (lockAmount <= 0) {\n    return 'You need to set a positive lock amount.'\n  }\n  if (lockDuration < 1 * MINUTE_IN_SECONDS) {\n    return 'Please ensure the lock duration is equal to or longer than 1 minute.'\n  }\n  return null\n}\n\nfunction LockScreen({\n  appLabel,\n  dataKey,\n  screenProps: { back, data, next, screenIndex, screens },\n  title,\n}) {\n  const screenData = (dataKey ? data[dataKey] : data) || {}\n  const { networkType } = useWallet()\n\n  const [lockAmount, setLockAmount] = useState(screenData.lockAmount || -1)\n  const [lockDuration, setLockDuration] = useState(\n    screenData.lockDuration || DEFAULT_DURATION\n  )\n  const [lockToken, setLockToken] = useState(\n    screenData.lockToken || EMPTY_TOKEN\n  )\n  const [spamPenalty, setSpamPenalty] = useState(\n    screenData.spamPenalty || DEFAULT_SPAM_PENALTY\n  )\n  const [formError, setFormError] = useState(null)\n\n  const handleLockAmountChange = useCallback(event => {\n    setFormError(null)\n\n    const value = parseInt(event.target.value, 10)\n    setLockAmount(isNaN(value) ? -1 : value)\n  }, [])\n\n  const handleLockDurationChange = useCallback(value => {\n    setFormError(null)\n    setLockDuration(value)\n  }, [])\n\n  const handleLockTokenChange = useCallback(({ token, selectedIndex }) => {\n    setFormError(null)\n    setLockToken({ data: token, selectedIndex })\n  }, [])\n\n  const handleSpamPenaltyChange = useCallback(event => {\n    setFormError(null)\n\n    const spamPenalty = event.target.value\n    setSpamPenalty(spamPenalty)\n  }, [])\n\n  const prevNextRef = useRef()\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n      const error = validationError(\n        lockAmount,\n        lockDuration,\n        lockToken.data.address\n      )\n      setFormError(error)\n\n      if (!error) {\n        const screenData = {\n          lockAmount,\n          lockDuration,\n          lockToken,\n          spamPenalty,\n        }\n        next(dataKey ? { ...data, [dataKey]: screenData } : screenData)\n      }\n    },\n    [lockAmount, lockDuration, lockToken, spamPenalty, next, dataKey, data]\n  )\n\n  const disableNext = lockAmount < 0 || !lockToken.data.address\n\n  return (\n    <form\n      css={`\n        display: grid;\n        align-items: center;\n        justify-content: center;\n      `}\n    >\n      <Header\n        title={title}\n        subtitle={\n          <span\n            css={`\n              display: flex;\n              align-items: center;\n              justify-content: center;\n            `}\n          >\n            Choose your\n            <span\n              css={`\n                display: flex;\n                margin: 0 ${1.5 * GU}px;\n              `}\n            >\n              <KnownAppBadge\n                appName=\"time-lock.aragonpm.eth\"\n                label={appLabel}\n              />\n            </span>\n            settings below.\n          </span>\n        }\n      />\n\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        The Time Lock app is used to discourage spammy, low-quality proposal\n        submission by requiring users to lock tokens for a period of time\n        whenever they submit a proposal. The amount and duration of each lock\n        increases the more simultaneously active locks the user has accrued.\n      </Info>\n\n      <div\n        css={`\n          display: grid;\n          grid-template-columns: auto ${12 * GU}px;\n          grid-column-gap: ${1.5 * GU}px;\n        `}\n      >\n        <Field\n          label={\n            <React.Fragment>\n              Token to lock\n              <Help hint=\"What is Token to Lock?\">\n                <strong>Token to Lock</strong> is the address of the token to be\n                locked. This value cannot be easily modified, so pick wisely!\n              </Help>\n            </React.Fragment>\n          }\n        >\n          <TokenSelector\n            selectedIndex={lockToken.selectedIndex}\n            onChange={handleLockTokenChange}\n            value={lockToken.data.address}\n            tokens={[getDefaultLockTokenByNetwork(networkType)]}\n          />\n        </Field>\n\n        <Field\n          label={\n            <React.Fragment>\n              Lock amount\n              <Help hint=\"What is Lock Amount?\">\n                <strong>Lock Amount</strong> is the amount of tokens a user will\n                need to lock in order to perform an action that has been\n                protected by the Time Lock app.\n              </Help>\n            </React.Fragment>\n          }\n        >\n          <TextInput\n            onChange={handleLockAmountChange}\n            value={lockAmount === -1 ? '' : lockAmount}\n            wide\n          />\n        </Field>\n        <div>\n          <Duration\n            duration={lockDuration}\n            onUpdate={handleLockDurationChange}\n            label={\n              <React.Fragment>\n                Lock duration\n                <Help hint=\"What is Lock Duration?\">\n                  <strong>Lock Duration</strong> is the period of time that the\n                  tokens will be locked.\n                </Help>\n              </React.Fragment>\n            }\n          />\n\n          <Field\n            label={\n              <React.Fragment>\n                Spam penalty %\n                <Help hint=\"What is Spam Penalty?\">\n                  <strong>Spam Penalty</strong> is a percentage representing the\n                  rate token amounts and durations grow as users create\n                  overlapping locks. For each additional overlapping lock, the\n                  required token amount and duration of the next lock will be\n                  increased by this percentage multiplied by the base token\n                  amount and duration.\n                </Help>\n              </React.Fragment>\n            }\n          >\n            <TextInput\n              type=\"number\"\n              step={1}\n              onChange={handleSpamPenaltyChange}\n              value={spamPenalty}\n              css={`\n                max-width: ${17 * GU}px;\n              `}\n            />\n            <span> %</span>\n          </Field>\n        </div>\n      </div>\n\n      {formError && (\n        <Info\n          mode=\"error\"\n          css={`\n            margin-bottom: ${3 * GU}px;\n          `}\n        >\n          {formError}\n        </Info>\n      )}\n\n      <Navigation\n        ref={prevNextRef}\n        backEnabled\n        nextEnabled={!disableNext}\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </form>\n  )\n}\n\nLockScreen.propTypes = {\n  appLabel: PropTypes.string,\n  dataKey: PropTypes.string,\n  screenProps: ScreenPropsType.isRequired,\n  title: PropTypes.string,\n}\n\nLockScreen.defaultProps = {\n  appLabel: 'Time Lock',\n  dataKey: 'lock',\n  title: 'Configure template',\n}\n\nfunction formatReviewFields(screenData) {\n  const { lockToken, lockAmount, lockDuration, spamPenalty } = screenData\n  return [\n    [\n      'Token',\n      `${lockToken.data.symbol} (${lockToken.data.name} ${shortenAddress(\n        lockToken.data.address\n      )})`,\n    ],\n    ['Lock amount', `${lockAmount} ${lockAmount === 1 ? 'token' : 'tokens'}`],\n    ['Lock duration', formatDuration(lockDuration)],\n    ['Spam penalty', `${spamPenalty} %`],\n  ]\n}\n\nLockScreen.formatReviewFields = formatReviewFields\nexport default LockScreen\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Button, IconPlus, IconTrash, GU, useTheme } from '@aragon/ui'\nimport TokenSelector from './TokenSelector'\n\nfunction MultiTokenSelector({\n  onAddToken,\n  onRemoveToken,\n  onUpdateToken,\n  tokens,\n  items,\n}) {\n  const theme = useTheme()\n\n  return (\n    <div>\n      <div>\n        {tokens.map(({ token, selectedIndex }, index) => (\n          <TokenSelectorItem\n            key={index}\n            index={index}\n            selectedIndex={selectedIndex}\n            token={token}\n            onUpdateToken={onUpdateToken}\n            onRemoveToken={onRemoveToken}\n            items={items}\n          />\n        ))}\n      </div>\n      <Button\n        icon={\n          <IconPlus\n            css={`\n              color: ${theme.accent};\n            `}\n          />\n        }\n        label=\"Add more\"\n        onClick={onAddToken}\n      />\n    </div>\n  )\n}\n\nconst TokenSelectorItem = ({\n  index,\n  selectedIndex,\n  token,\n  onUpdateToken,\n  onRemoveToken,\n  items,\n}) => {\n  const theme = useTheme()\n\n  const handleRemove = useCallback(() => {\n    onRemoveToken(index)\n  }, [index, onRemoveToken])\n\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: ${selectedIndex === 0 ? 'baseline' : 'center'};\n        margin-bottom: ${1.5 * GU}px;\n        width: 100%;\n      `}\n    >\n      <TokenSelector\n        componentIndex={index}\n        selectedIndex={selectedIndex}\n        onChange={onUpdateToken}\n        tokens={items}\n        value={token.address}\n        showCustomMode=\"horizontal\"\n      />\n      {index !== 0 && (\n        <Button\n          display=\"icon\"\n          icon={\n            <IconTrash\n              css={`\n                color: ${theme.negative};\n              `}\n            />\n          }\n          label=\"Remove\"\n          onClick={handleRemove}\n          size=\"mini\"\n        />\n      )}\n    </div>\n  )\n}\n\nTokenSelectorItem.propTypes = {\n  index: PropTypes.number.isRequired,\n  selectedIndex: PropTypes.number.isRequired,\n  token: PropTypes.object.isRequired,\n  onUpdateToken: PropTypes.func,\n  onRemoveToken: PropTypes.func,\n  items: PropTypes.array,\n}\n\nMultiTokenSelector.propTypes = {\n  onAddToken: PropTypes.func.isRequired,\n  onRemoveToken: PropTypes.func,\n  onUpdateToken: PropTypes.func.isRequired,\n  tokens: PropTypes.array.isRequired,\n  items: PropTypes.array.isRequired,\n}\n\nexport default MultiTokenSelector\n","import React, { useCallback, useState, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { addressesEqual, Field, GU, Help, Info, isAddress } from '@aragon/ui'\nimport {\n  Header,\n  Navigation,\n  ScreenPropsType,\n  KnownAppBadge,\n} from '../../../kit'\nimport MultiTokenSelector from '../../components/TokenSelector/MultiTokenSelector'\nimport {\n  getDefaultRedeemableTokens,\n  TOKEN_FAKE_ADDRESS,\n} from '../helpers/tokens'\nimport { shortenAddress } from '../../../../util/web3'\nimport { useWallet } from '../../../../contexts/wallet'\n\nfunction validationError(redeemableTokens) {\n  if (redeemableTokens.length === 0) {\n    return 'You need to select at least one redeemable token.'\n  }\n\n  const notValidAddress = redeemableTokens.some(\n    ({ token }) => !isAddress(token.address)\n  )\n\n  if (notValidAddress) {\n    return 'One or more selected tokens are not valid addresses.'\n  }\n\n  return null\n}\n\nconst EMPTY_TOKEN = { token: { address: '' }, selectedIndex: -1 }\n\nfunction RedemptionsScreen({\n  appLabel,\n  dataKey,\n  screenProps: { back, data, next, screenIndex, screens },\n  title,\n}) {\n  const screenData = (dataKey ? data[dataKey] : data) || {}\n  const { networkType } = useWallet()\n\n  const [redeemableTokens, setRedeemableTokens] = useState(\n    screenData.redeemableTokens && screenData.redeemableTokens.length > 0\n      ? screenData.redeemableTokens\n      : [EMPTY_TOKEN]\n  )\n\n  const [formError, setFormError] = useState(null)\n\n  const prevNextRef = useRef()\n\n  const handleTokenAdded = useCallback(() => {\n    setFormError(null)\n    setRedeemableTokens(redeemableTokens => [...redeemableTokens, EMPTY_TOKEN])\n  }, [])\n\n  const handleTokenRemoved = useCallback(index => {\n    setFormError(null)\n    setRedeemableTokens(redeemableTokens =>\n      redeemableTokens.filter((_, i) => i !== index)\n    )\n  }, [])\n\n  const handleTokenUpdated = useCallback(\n    ({ token: newToken, selectedIndex: newSelectedIndex, componentIndex }) => {\n      const duplicate = redeemableTokens.some(\n        ({ token }, index) =>\n          isAddress(newToken.address) &&\n          index !== componentIndex &&\n          addressesEqual(token.address, newToken.address)\n      )\n\n      if (duplicate) {\n        setFormError('Token already selected')\n        return\n      }\n\n      setFormError(null)\n\n      setRedeemableTokens(redeemableTokens =>\n        redeemableTokens.map((item, i) =>\n          i === componentIndex\n            ? { token: newToken, selectedIndex: newSelectedIndex }\n            : item\n        )\n      )\n    },\n    [redeemableTokens]\n  )\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n\n      const filteredRedeemableTokens = redeemableTokens.filter(\n        ({ token }) => token.address !== ''\n      )\n\n      const error = validationError(filteredRedeemableTokens)\n      setFormError(error)\n\n      if (!error) {\n        const screenData = {\n          redeemableTokens: filteredRedeemableTokens,\n        }\n        next(dataKey ? { ...data, [dataKey]: screenData } : screenData)\n      }\n    },\n    [redeemableTokens, next, dataKey, data]\n  )\n\n  const nextEnabled = Boolean(redeemableTokens[0].token.address)\n\n  return (\n    <form>\n      <Header\n        title={title}\n        subtitle={\n          <span\n            css={`\n              display: flex;\n              align-items: center;\n              justify-content: center;\n            `}\n          >\n            Choose your\n            <span\n              css={`\n                display: flex;\n                margin: 0 ${1.5 * GU}px;\n              `}\n            >\n              <KnownAppBadge\n                appName=\"redemptions.aragonpm.eth\"\n                label={appLabel}\n              />\n            </span>\n            settings below.\n          </span>\n        }\n      />\n\n      <div\n        css={`\n          margin-bottom: ${2 * GU}px;\n        `}\n      >\n        <Field\n          label={\n            <React.Fragment>\n              Redeemable tokens\n              <Help hint=\"What are redeemable tokens?\">\n                <strong>Redeemable tokens</strong> are tokens (ETH or ERC-20)\n                that can be redeemed in exchange for the organization's tokens.\n                They represent assets held by the organization.\n              </Help>\n            </React.Fragment>\n          }\n          css={`\n            margin: 0;\n          `}\n        />\n        <MultiTokenSelector\n          onAddToken={handleTokenAdded}\n          onRemoveToken={handleTokenRemoved}\n          onUpdateToken={handleTokenUpdated}\n          tokens={redeemableTokens}\n          items={getDefaultRedeemableTokens(networkType)}\n        />\n      </div>\n\n      {formError && (\n        <Info\n          mode=\"error\"\n          css={`\n            margin-bottom: ${3 * GU}px;\n          `}\n        >\n          {formError}\n        </Info>\n      )}\n\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        These settings determine which tokens (ETH and ERC-20) held by the\n        organization will be eligible for redemption.\n      </Info>\n\n      <Navigation\n        ref={prevNextRef}\n        backEnabled\n        nextEnabled={nextEnabled}\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </form>\n  )\n}\n\nRedemptionsScreen.propTypes = {\n  appLabel: PropTypes.string,\n  dataKey: PropTypes.string,\n  screenProps: ScreenPropsType.isRequired,\n  title: PropTypes.string,\n}\n\nRedemptionsScreen.defaultProps = {\n  appLabel: 'Redemptions',\n  dataKey: 'redemptions',\n  title: 'Configure template',\n}\n\nfunction formatReviewFields(screenData) {\n  return [\n    [\n      'Redeemable tokens',\n      <div>\n        {screenData.redeemableTokens.map(({ token }, index) => (\n          <div\n            key={index}\n            css={`\n              display: grid;\n              grid-template-columns: 1fr 2fr;\n            `}\n          >\n            <span>{token.symbol || 'Custom token'}</span>\n            {!addressesEqual(token.address, TOKEN_FAKE_ADDRESS) && (\n              <span> {shortenAddress(token.address)}</span>\n            )}\n          </div>\n        ))}\n      </div>,\n    ],\n  ]\n}\n\nRedemptionsScreen.formatReviewFields = formatReviewFields\nexport default RedemptionsScreen\n","import React, { useCallback, useState, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { addressesEqual, Field, GU, Help, Info, isAddress } from '@aragon/ui'\nimport {\n  Header,\n  Navigation,\n  ScreenPropsType,\n  KnownAppBadge,\n} from '../../../kit'\nimport MultiTokenSelector from '../../components/TokenSelector/MultiTokenSelector'\nimport { getDefaultAcceptedTokens, TOKEN_FAKE_ADDRESS } from '../helpers/tokens'\nimport { shortenAddress } from '../../../../util/web3'\nimport { useWallet } from '../../../../contexts/wallet'\n\nfunction validationError(acceptedTokens) {\n  if (acceptedTokens.length === 0) {\n    return 'You need to select at least one accepted token.'\n  }\n\n  const notValidAddress = acceptedTokens.some(\n    ({ token }) => !isAddress(token.address)\n  )\n\n  if (notValidAddress) {\n    return 'One or more selected tokens are not valid addresses.'\n  }\n\n  return null\n}\n\nconst EMPTY_TOKEN = { token: { address: '' }, selectedIndex: -1 }\n\nfunction TokenRequestScreen({\n  appLabel,\n  dataKey,\n  screenProps: { back, data, next, screenIndex, screens },\n  title,\n}) {\n  const screenData = (dataKey ? data[dataKey] : data) || {}\n  const { networkType } = useWallet()\n\n  const [acceptedTokens, setAcceptedTokens] = useState(\n    screenData.acceptedTokens && screenData.acceptedTokens.length > 0\n      ? screenData.acceptedTokens\n      : [EMPTY_TOKEN]\n  )\n\n  const [formError, setFormError] = useState(null)\n\n  const prevNextRef = useRef()\n\n  const handleTokenAdded = useCallback(() => {\n    setFormError(null)\n    setAcceptedTokens(acceptedTokens => [...acceptedTokens, EMPTY_TOKEN])\n  }, [])\n\n  const handleTokenRemoved = useCallback(index => {\n    setFormError(null)\n    setAcceptedTokens(acceptedTokens =>\n      acceptedTokens.filter((_, i) => i !== index)\n    )\n  }, [])\n\n  const handleTokenUpdated = useCallback(\n    ({ token: newToken, selectedIndex: newSelectedIndex, componentIndex }) => {\n      const duplicate = acceptedTokens.some(\n        ({ token }, index) =>\n          isAddress(newToken.address) &&\n          index !== componentIndex &&\n          addressesEqual(token.address, newToken.address)\n      )\n\n      if (duplicate) {\n        setFormError('Token already selected')\n        return\n      }\n\n      setFormError(null)\n\n      setAcceptedTokens(acceptedTokens =>\n        acceptedTokens.map((item, i) =>\n          i === componentIndex\n            ? { token: newToken, selectedIndex: newSelectedIndex }\n            : item\n        )\n      )\n    },\n    [acceptedTokens]\n  )\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n\n      const filteredAcceptedTokens = acceptedTokens.filter(\n        ({ token }) => token.address !== ''\n      )\n\n      const error = validationError(filteredAcceptedTokens)\n      setFormError(error)\n\n      if (!error) {\n        const screenData = {\n          acceptedTokens: filteredAcceptedTokens,\n        }\n        next(dataKey ? { ...data, [dataKey]: screenData } : screenData)\n      }\n    },\n    [acceptedTokens, next, dataKey, data]\n  )\n\n  const nextEnabled = Boolean(acceptedTokens[0].token.address)\n\n  return (\n    <form>\n      <Header\n        title={title}\n        subtitle={\n          <span\n            css={`\n              display: flex;\n              align-items: center;\n              justify-content: center;\n            `}\n          >\n            Choose your\n            <span\n              css={`\n                display: flex;\n                margin: 0 ${1.5 * GU}px;\n              `}\n            >\n              <KnownAppBadge\n                appName=\"token-request.aragonpm.eth\"\n                label={appLabel}\n              />\n            </span>\n            settings below.\n          </span>\n        }\n      />\n\n      <div\n        css={`\n          margin-bottom: ${2 * GU}px;\n        `}\n      >\n        <Field\n          label={\n            <React.Fragment>\n              Accepted Tokens\n              <Help hint=\"What are the accepted tokens?\">\n                <strong>Accepted tokens</strong> are ERC20 tokens that will be\n                accepted as payment in exchange for the organization's tokens\n              </Help>\n            </React.Fragment>\n          }\n          css={`\n            margin: 0;\n          `}\n        />\n        <MultiTokenSelector\n          onAddToken={handleTokenAdded}\n          onRemoveToken={handleTokenRemoved}\n          onUpdateToken={handleTokenUpdated}\n          tokens={acceptedTokens}\n          items={getDefaultAcceptedTokens(networkType)}\n        />\n      </div>\n\n      {formError && (\n        <Info\n          mode=\"error\"\n          css={`\n            margin-bottom: ${3 * GU}px;\n          `}\n        >\n          {formError}\n        </Info>\n      )}\n\n      <Info\n        css={`\n          margin-bottom: ${3 * GU}px;\n        `}\n      >\n        These settings will determine which assets will be accepted as payment\n        in exchange for the organization's tokens.\n      </Info>\n\n      <Navigation\n        ref={prevNextRef}\n        backEnabled\n        nextEnabled={nextEnabled}\n        nextLabel={`Next: ${screens[screenIndex + 1][0]}`}\n        onBack={back}\n        onNext={handleSubmit}\n      />\n    </form>\n  )\n}\n\nTokenRequestScreen.propTypes = {\n  appLabel: PropTypes.string,\n  dataKey: PropTypes.string,\n  screenProps: ScreenPropsType.isRequired,\n  title: PropTypes.string,\n}\n\nTokenRequestScreen.defaultProps = {\n  appLabel: 'Token Request',\n  dataKey: 'tokenRequest',\n  title: 'Configure template',\n}\n\nfunction formatReviewFields(screenData) {\n  return [\n    [\n      'Accepted tokens',\n      <div>\n        {screenData.acceptedTokens.map(({ token }, index) => (\n          <div\n            key={index}\n            css={`\n              display: grid;\n              grid-template-columns: 1fr 2fr;\n            `}\n          >\n            <span>{token.symbol || 'Custom token'}</span>\n            {!addressesEqual(token.address, TOKEN_FAKE_ADDRESS) && (\n              <span> {shortenAddress(token.address)}</span>\n            )}\n          </div>\n        ))}\n      </div>,\n    ],\n  ]\n}\n\nTokenRequestScreen.formatReviewFields = formatReviewFields\nexport default TokenRequestScreen\n","export { default as DandelionVotingScreen } from './screens/DandelionVotingScreen'\nexport { default as LockScreen } from './screens/LockScreen'\nexport { default as RedemptionsScreen } from './screens/RedemptionsScreen'\nexport { default as TokenRequestScreen } from './screens/TokenRequestScreen'\n","// Estimates based on block propagation rates in Feb. 2020\nconst NETWORK_TIMES = new Map([\n  ['main', 13],\n  ['kovan', 4],\n  ['rinkeby', 14],\n  ['ropsten', 11],\n  ['goerli', 15],\n  ['private', 2],\n  ['matic', 2],\n  ['mumbai', 2],\n])\nexport default function getBlockTime(networkType) {\n  return NETWORK_TIMES.get(networkType) || null\n}\n","/* eslint-disable react/prop-types */\nimport React from 'react'\nimport BN from 'bn.js'\nimport {\n  ClaimDomainScreen,\n  KnownAppBadge,\n  ReviewScreen,\n  TokensScreen,\n} from '../kit'\nimport {\n  DandelionVotingScreen,\n  LockScreen,\n  RedemptionsScreen,\n  TokenRequestScreen,\n} from './config'\n\nimport getBlockTime from './config/helpers/getBlockTime'\nimport header from './header.svg'\nimport icon from './icon.svg'\n\nconst onePercent = new BN(10).pow(new BN(16))\n\nfunction completeDomain(domain) {\n  return domain ? `${domain}.aragonid.eth` : ''\n}\n\nfunction adjustVotingSettings(support, quorum) {\n  // The max value for both support and quorum is 100% - 1\n  const onePercent = new BN(10).pow(new BN(16))\n  const hundredPercent = onePercent.mul(new BN(100))\n\n  let adjustedSupport = onePercent.mul(new BN(support))\n  if (adjustedSupport.eq(hundredPercent)) {\n    adjustedSupport = adjustedSupport.sub(new BN(1))\n  }\n\n  let adjustedQuorum = onePercent.mul(new BN(quorum))\n  if (adjustedQuorum.eq(hundredPercent)) {\n    adjustedQuorum = adjustedQuorum.sub(new BN(1))\n  }\n\n  return [adjustedSupport.toString(), adjustedQuorum.toString()]\n}\n\nexport default {\n  id: 'dandelion-org-template.aragonpm.eth',\n  name: 'Dandelion',\n  new: true,\n  header,\n  icon,\n  description: `\n  Facilitate collaboration with an organization that makes it easy for contributors to simply part ways when disagreements occur.\n  `,\n  userGuideUrl: 'https://1hive.org/dandelion',\n  sourceCodeUrl: 'https://github.com/1hive/dandelion-org',\n  registry: 'aragonpm.eth',\n  apps: [\n    { appName: 'token-manager.aragonpm.eth', label: 'Tokens' },\n    { appName: 'finance.aragonpm.eth', label: 'Finance' },\n    {\n      appName: 'dandelion-voting.aragonpm.eth',\n      label: 'Voting',\n    },\n    { appName: 'time-lock.aragonpm.eth', label: 'Time Lock' },\n    { appName: 'redemptions.aragonpm.eth', label: 'Redemptions' },\n    { appName: 'token-request.aragonpm.eth', label: 'Token Request' },\n  ],\n  optionalApps: [{ appName: 'agent.aragonpm.eth', label: 'Agent' }],\n  screens: [\n    [\n      data => completeDomain(data.domain) || 'Claim domain',\n      props => <ClaimDomainScreen screenProps={props} />,\n    ],\n    [\n      'Configure template',\n      props => <DandelionVotingScreen screenProps={props} />,\n    ],\n    ['Configure template', props => <TokensScreen screenProps={props} />],\n    ['Configure template', props => <LockScreen screenProps={props} />],\n    ['Configure template', props => <RedemptionsScreen screenProps={props} />],\n    ['Configure template', props => <TokenRequestScreen screenProps={props} />],\n\n    [\n      'Review information',\n      props => {\n        const {\n          domain,\n          voting,\n          tokens,\n          lock,\n          redemptions,\n          tokenRequest,\n        } = props.data\n        return (\n          <ReviewScreen\n            screenProps={props}\n            items={[\n              {\n                label: 'General info',\n                fields: [\n                  ['Organization template', 'Dandelion'],\n                  ['Name', completeDomain(domain)],\n                ],\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"dandelion-voting.aragonpm.eth\"\n                    label=\"Voting\"\n                  />\n                ),\n                fields: DandelionVotingScreen.formatReviewFields(voting),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"token-manager.aragonpm.eth\"\n                    label=\"Tokens\"\n                  />\n                ),\n                fields: TokensScreen.formatReviewFields(tokens),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"time-lock.aragonpm.eth\"\n                    label=\"Time lock\"\n                  />\n                ),\n                fields: LockScreen.formatReviewFields(lock),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"redemptions.aragonpm.eth\"\n                    label=\"Redemptions\"\n                  />\n                ),\n                fields: RedemptionsScreen.formatReviewFields(redemptions),\n              },\n              {\n                label: (\n                  <KnownAppBadge\n                    appName=\"token-request.aragonpm.eth\"\n                    label=\"Token Request\"\n                  />\n                ),\n                fields: TokenRequestScreen.formatReviewFields(tokenRequest),\n              },\n            ]}\n          />\n        )\n      },\n    ],\n  ],\n  prepareTransactions(createTx, data, networkType) {\n    const {\n      domain,\n      optionalApps = [],\n      tokens,\n      voting,\n      lock,\n      redemptions,\n      tokenRequest,\n    } = data\n    const useAgentAsVault = optionalApps.includes('agent.aragonpm.eth')\n    const blockTime = getBlockTime(networkType)\n\n    // Tokens app\n    const { tokenName, tokenSymbol, members } = tokens\n    const baseStake = new BN(10).pow(new BN(18))\n    const stakes = members.map(([_, stake]) =>\n      baseStake.mul(new BN(stake.toString())).toString()\n    )\n    const accounts = members.map(([account]) => account)\n\n    // Finance app\n    const financePeriod = 0 // Fallback to default 30 days\n\n    // Voting app\n    const { support, quorum, duration, buffer, delay } = voting\n\n    const [adjustedSupport, adjustedQuorum] = adjustVotingSettings(\n      support,\n      quorum\n    )\n    const numericVotingDuration = duration / blockTime\n    const adjustedDuration = new BN(numericVotingDuration).toString()\n\n    const numericBuffer = buffer / blockTime\n    const adjustedBuffer = new BN(numericBuffer).toString()\n\n    const numericDelay = delay / blockTime\n    const adjustedDelay = new BN(numericDelay).toString()\n\n    const votingSettings = [\n      adjustedSupport,\n      adjustedQuorum,\n      adjustedDuration,\n      adjustedBuffer,\n      adjustedDelay,\n    ]\n\n    // Time Lock app\n    const { lockDuration, lockAmount, spamPenalty, lockToken } = lock\n    const lockTokenAddress = lockToken.data.address\n    const adjustedLockDuration = new BN(lockDuration).toString()\n    const adjustedLockAmount = new BN(lockAmount.toString()).toString()\n    const adjustedSpamPenalty = onePercent.mul(new BN(spamPenalty)).toString()\n    const lockSettings = [\n      adjustedLockDuration,\n      adjustedLockAmount,\n      adjustedSpamPenalty,\n    ]\n\n    // Redemptions apps\n    const redeemableTokens = redemptions.redeemableTokens.map(\n      ({ token }) => token.address\n    )\n\n    // Token Request app\n    const acceptedDepositToken = tokenRequest.acceptedTokens\n      .map(({ token }) => token.address)\n      .sort()\n\n    return [\n      {\n        name: 'Create organization',\n        transaction: createTx('newTokenAndBaseInstance', [\n          tokenName,\n          tokenSymbol,\n          accounts,\n          stakes,\n          financePeriod,\n          useAgentAsVault,\n        ]),\n      },\n      {\n        name: 'Install dandelion apps',\n        transaction: createTx('installDandelionApps', [\n          domain,\n          redeemableTokens,\n          acceptedDepositToken,\n          lockTokenAddress,\n          lockSettings,\n          votingSettings,\n        ]),\n      },\n    ]\n  },\n}\n","import company from './company'\nimport fundraising from './fundraising'\nimport membership from './membership'\nimport openEnterprise from './open-enterprise'\nimport reputation from './reputation'\nimport dandelion from './dandelion'\n\n// see the corresponding prop type, OrgTemplateType, in prop-types.js.\n\nexport default [\n  company,\n  membership,\n  reputation,\n  openEnterprise,\n  dandelion,\n  fundraising,\n]\n","import BN from 'bn.js'\nimport { fromWei, toWei, formatBalance } from '../util/web3'\n\nconst MINIMUM_BALANCE = new BN(toWei('0.2'))\nconst BALANCE_DECIMALS = 3\n\nfunction isBalanceUnknown(balance) {\n  return !balance || balance.eqn(-1)\n}\n\nfunction localFormatBalance(balance) {\n  return isBalanceUnknown(balance)\n    ? '0'\n    : formatBalance(balance, { precision: BALANCE_DECIMALS })\n}\n\nfunction validateCreationRequirements(\n  account,\n  balance,\n  isContractAccount,\n  tokenSymbol\n) {\n  if (!account) {\n    return ['no-account']\n  }\n  if (\n    !isBalanceUnknown(balance) &&\n    balance.lt(MINIMUM_BALANCE) &&\n    !(isContractAccount === true)\n  ) {\n    return [\n      'minimum-balance',\n      {\n        balance: localFormatBalance(balance),\n        minimumBalance: fromWei(String(MINIMUM_BALANCE)),\n        tokenSymbol: tokenSymbol,\n      },\n    ]\n  }\n  return [null]\n}\n\nexport default validateCreationRequirements\n","import React, { useCallback, useEffect, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport throttle from 'lodash.throttle'\nimport { BREAKPOINTS, useTheme } from '@aragon/ui'\nimport {\n  TEMPLATE_AVAILABLE,\n  TEMPLATE_LOADING,\n  TEMPLATE_UNAVAILABLE,\n} from '../symbols'\nimport Create from '../Create/Create'\nimport OnboardingTopBar from './OnboardingTopBar'\nimport Welcome from '../Welcome/Welcome'\nimport embeddedTemplates from '../../templates'\nimport { log } from '../../util/utils'\nimport { resolveEnsDomain } from '../../aragonjs-wrapper'\nimport { saveTemplateState } from '../create-utils'\nimport { useRouting } from '../../routing'\nimport { useWallet } from '../../contexts/wallet'\nimport { chains } from 'use-wallet'\nimport validateCreationRequirements from '../validate-requirements'\nimport { getWeb3 } from '../../util/web3'\nimport styled from 'styled-components'\nimport { NetworkSwitchModal, ConnectModal } from '../../components/Modals'\nimport { trackEvent, events } from '../../analytics'\n\nconst initialEmbeddedTemplates = embeddedTemplates.map(template => ({\n  ...template,\n  status: TEMPLATE_LOADING,\n}))\n\nfunction Onboarding({ web3 }) {\n  const theme = useTheme()\n  const routing = useRouting()\n\n  const {\n    networkType,\n    account,\n    balance,\n    chainId,\n    isContract: isContractAccount,\n    web3: walletWeb3,\n  } = useWallet()\n\n  const [connectModalOpened, setConnectModalOpened] = useState(false)\n  const [networkModalOpened, setNetworkModalOpened] = useState(false)\n  const [templates, setTemplates] = useState(initialEmbeddedTemplates)\n  const [connectIntent, setConnectIntent] = useState('')\n  const [requirementsError, setRequirementsError] = useState([null])\n\n  const status =\n    (routing.mode.name === 'onboarding' && routing.mode.status) || 'none'\n\n  const goToHome = useCallback(() => {\n    routing.update(locator => ({\n      ...locator,\n      mode: { name: 'onboarding', status: null },\n    }))\n  }, [routing])\n\n  const goToOpen = useCallback(() => {\n    routing.update(locator => ({\n      ...locator,\n      mode: { name: 'onboarding', status: 'open' },\n    }))\n\n    // analytics\n    trackEvent(events.OPEN_ORGANIZATION_CLICKED, {\n      network: networkType,\n    })\n  }, [routing, networkType])\n\n  const goToCreate = useCallback(() => {\n    routing.update(locator => ({\n      ...locator,\n      mode: { name: 'onboarding', status: 'create' },\n    }))\n\n    // analytics\n    trackEvent(events.CREATE_ORGANIZATION_CLICKED, {\n      network: networkType,\n    })\n  }, [routing, networkType])\n\n  const goToOrg = useCallback(\n    orgAddress => {\n      routing.update(locator => ({\n        ...locator,\n        mode: { name: 'org', orgAddress },\n      }))\n    },\n    [routing]\n  )\n\n  // Update the requirements live if an error is being displayed,\n  // on click otherwise (see handleCreate).\n  useEffect(() => {\n    const requirementsErrorUpdated = validateCreationRequirements(\n      account,\n      balance,\n      isContractAccount,\n      chains.getChainInformation(chainId)?.nativeCurrency.symbol\n    )\n\n    if (\n      requirementsError[0] !== null &&\n      requirementsError[0] !== requirementsErrorUpdated[0]\n    ) {\n      setRequirementsError(requirementsErrorUpdated)\n    }\n  }, [account, balance, chainId, isContractAccount, requirementsError])\n\n  const handleCreate = useCallback(() => {\n    // reset the creation state\n    saveTemplateState({ networkType })\n\n    const requirementsError = validateCreationRequirements(\n      account,\n      balance,\n      isContractAccount,\n      chains.getChainInformation(chainId)?.nativeCurrency.symbol\n    )\n    setRequirementsError(requirementsError)\n\n    // Account not connected\n    if (requirementsError[0] === 'no-account') {\n      setConnectIntent('create')\n      setConnectModalOpened(true)\n      return\n    }\n\n    // No error, we can go to create straight away\n    if (requirementsError[0] === null) {\n      goToCreate()\n    }\n  }, [account, balance, chainId, goToCreate, isContractAccount, networkType])\n\n  const closeConnectModal = useCallback(\n    provider => {\n      setConnectModalOpened(false)\n      setConnectIntent('')\n\n      // Redirect to / if the modal get closed on /create\n      // without having connected an account.\n      if (status === 'create' && !account) {\n        goToHome()\n      }\n    },\n    [account, goToHome, status]\n  )\n\n  const closeNetworkSwitchModal = useCallback(\n    () => setNetworkModalOpened(false),\n    []\n  )\n  const openNetworkSwitchModal = useCallback(\n    () => setNetworkModalOpened(true),\n    []\n  )\n\n  const handleProviderConnect = useCallback(\n    provider => {\n      closeConnectModal()\n\n      // For now this is always true, but it may change in the future\n      if (connectIntent === 'create') {\n        goToCreate()\n      }\n    },\n    [closeConnectModal, connectIntent, goToCreate]\n  )\n\n  const connectProviderError = useCallback(\n    (provider, err) => {\n      closeConnectModal()\n    },\n    [closeConnectModal]\n  )\n\n  useEffect(() => {\n    let cancelled = false\n    if (status === 'create') {\n      Promise.all(\n        embeddedTemplates.map(async template => {\n          let repoAddress\n          try {\n            repoAddress = await resolveEnsDomain(networkType, web3, template.id)\n          } catch (_) {}\n\n          return repoAddress\n            ? {\n                repoAddress,\n                status: TEMPLATE_AVAILABLE,\n                ...template,\n              }\n            : {\n                status: TEMPLATE_UNAVAILABLE,\n                ...template,\n              }\n        })\n      )\n        .then(templatesWithRepoAddress => {\n          if (!cancelled) {\n            const availableTemplates = templatesWithRepoAddress.filter(\n              item => item.status === TEMPLATE_AVAILABLE\n            )\n            setTemplates(availableTemplates)\n          }\n          return null\n        })\n        .catch(err => {\n          log('Failed to resolve templates through ENS', err)\n        })\n    }\n    return () => {\n      cancelled = true\n    }\n  }, [status, web3, networkType])\n\n  useEffect(() => {\n    if (status !== 'create') {\n      return\n    }\n\n    // Even when connected, the account usually arrives after some delay.\n    const id = setTimeout(() => {\n      if (!account) {\n        setConnectModalOpened(true)\n      }\n    }, 1000)\n\n    return () => {\n      clearTimeout(id)\n    }\n  }, [status, account])\n\n  const [solidTopBar, setSolidTopBar] = useState(false)\n\n  const updateSolidScrollBar = useCallback(\n    throttle(solid => {\n      setSolidTopBar(solid)\n    }, 50),\n    []\n  )\n\n  const handleOnBoardingScroll = useCallback(\n    event => {\n      updateSolidScrollBar(event.target.scrollTop > 0)\n    },\n    [updateSolidScrollBar]\n  )\n\n  if (status === 'none') {\n    return null\n  }\n\n  return (\n    <div css=\"position: relative; z-index: 1\">\n      <OnboardingTopBar\n        status={status}\n        solid={solidTopBar}\n        modalOpener={openNetworkSwitchModal}\n      />\n      <OnboardingMain\n        backgroundColor={theme.background}\n        onScroll={handleOnBoardingScroll}\n      >\n        {(status === 'welcome' || status === 'open') && (\n          <Welcome\n            createError={requirementsError}\n            onBack={goToHome}\n            onOpen={goToOpen}\n            onOpenOrg={goToOrg}\n            onCreate={handleCreate}\n            openMode={status === 'open'}\n          />\n        )}\n        {status === 'create' && Array.isArray(templates) && (\n          <Create\n            account={account}\n            onOpenOrg={goToOrg}\n            goToHome={goToHome}\n            templates={templates}\n            walletWeb3={walletWeb3}\n            web3={getWeb3(web3)}\n          />\n        )}\n\n        <ConnectModal\n          account={account}\n          onClose={closeConnectModal}\n          visible={connectModalOpened}\n          onConnect={handleProviderConnect}\n          onConnectError={connectProviderError}\n        />\n        <NetworkSwitchModal\n          visible={networkModalOpened}\n          onClose={closeNetworkSwitchModal}\n        />\n      </OnboardingMain>\n    </div>\n  )\n}\n\nconst OnboardingMain = styled.div`\n  position: relative;\n  z-index: 1;\n  background: ${props => props.backgroundColor};\n  height: 100vh;\n  min-width: ${BREAKPOINTS.min}px;\n  overflow-y: auto;\n`\n\nOnboarding.propTypes = {\n  web3: PropTypes.object,\n}\n\nexport default Onboarding\n","import Onboarding from './Onboarding/Onboarding'\n\nexport { Onboarding }\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { useWallet } from '../contexts/wallet'\nimport StoredList from '../StoredList'\nimport { EthereumAddressType } from '../prop-types'\nimport {\n  ACTIVITY_STATUS_CONFIRMED,\n  ACTIVITY_STATUS_FAILED,\n  ACTIVITY_STATUS_PENDING,\n  ACTIVITY_STATUS_TIMED_OUT,\n  ACTIVITY_TYPE_TRANSACTION,\n} from '../symbols'\nimport { getLocalStorageKey } from '../util/utils'\n\nconst ActivityContext = React.createContext()\n\nconst TEN_MINUTES = 1000 * 60 * 10\n\n// Only used to serialize / deserialize the symbols\nconst SymbolsByName = new Map(\n  Object.entries({\n    ACTIVITY_STATUS_CONFIRMED,\n    ACTIVITY_STATUS_PENDING,\n    ACTIVITY_STATUS_FAILED,\n    ACTIVITY_STATUS_TIMED_OUT,\n    ACTIVITY_TYPE_TRANSACTION,\n  })\n)\n\nconst getStoredList = (networkType, daoDomain, account) =>\n  new StoredList(\n    getLocalStorageKey(`activity:${daoDomain}:${account}`, networkType),\n    {\n      preStringify: activity => ({\n        ...activity,\n        status: activity.status.description.replace('ACTIVITY_STATUS_', ''),\n        type: activity.type.description.replace('ACTIVITY_TYPE_', ''),\n      }),\n      postParse: activity => ({\n        ...activity,\n        status: SymbolsByName.get(`ACTIVITY_STATUS_${activity.status}`),\n        type: SymbolsByName.get(`ACTIVITY_TYPE_${activity.type}`),\n      }),\n    }\n  )\n\n// Provides easy access to the user activities list\nclass ActivityProviderBase extends React.Component {\n  static propTypes = {\n    account: EthereumAddressType, // Current wallet\n    children: PropTypes.node,\n    daoDomain: PropTypes.string, // domain of current DAO\n    web3: PropTypes.object,\n    networkType: PropTypes.string.isRequired,\n  }\n  static defaultProps = {\n    account: '',\n  }\n\n  state = {\n    // activities of all accounts\n    activities: [],\n  }\n\n  _storedList = null\n\n  componentDidMount() {\n    this.updateStoredList()\n    this._checkInterval = setInterval(this.checkForTimedOut, 1000 * 30)\n  }\n\n  componentDidUpdate(prevProps) {\n    const { daoDomain, account, networkType } = this.props\n    if (\n      daoDomain !== prevProps.daoDomain ||\n      account !== prevProps.account ||\n      networkType !== prevProps.networkType\n    ) {\n      this.updateStoredList()\n    }\n  }\n\n  updateStoredList() {\n    const { daoDomain, account, networkType } = this.props\n    this._storedList = getStoredList(networkType, daoDomain, account)\n    this.setState(\n      { activities: this._storedList.getItems() },\n      this.refreshPendingActivities\n    )\n  }\n\n  componentWillUnmount() {\n    clearInterval(this._checkInterval)\n  }\n\n  // Refresh the status of pending activities\n  refreshPendingActivities() {\n    const { web3 } = this.props\n\n    this.state.activities\n      .filter(({ status }) => status === ACTIVITY_STATUS_PENDING)\n      .forEach(async ({ transactionHash }) => {\n        try {\n          const tx = await web3.eth.getTransaction(`${transactionHash}`)\n          // tx is null if no tx was found\n          if (tx && tx.blockNumber) {\n            this.setActivityConfirmed(transactionHash)\n          }\n        } catch (e) {\n          console.error(`Failed to refresh transaction ${transactionHash}`)\n        }\n      })\n  }\n\n  checkForTimedOut = () => {\n    const now = Date.now()\n    this.state.activities.forEach(activity => {\n      const timeDelta = now - activity.createdAt\n      if (\n        timeDelta > TEN_MINUTES &&\n        activity.status === ACTIVITY_STATUS_PENDING\n      ) {\n        // Set pending items to timed out after 10 minutes\n        this.setActivityTimedOut(activity.transactionHash)\n      }\n    })\n  }\n\n  addTransactionActivity = ({\n    transactionHash = '',\n    from = '',\n    targetAppProxyAddress = '',\n    forwarderProxyAddress = '',\n    description = '',\n  } = {}) => {\n    const newActivity = {\n      createdAt: Date.now(),\n      type: ACTIVITY_TYPE_TRANSACTION,\n      status: ACTIVITY_STATUS_PENDING,\n      read: false,\n      transactionHash,\n      // account address from which the transaction was created\n      from,\n      targetAppProxyAddress,\n      forwarderProxyAddress,\n      description,\n    }\n\n    const updatedActivities = this._storedList.add(newActivity)\n\n    this.setState({ activities: updatedActivities })\n  }\n\n  remove = index => {\n    this.setState({\n      activities: this._storedList.remove(index),\n    })\n  }\n\n  updateActivities = activities => {\n    this.setState({\n      activities: this._storedList.update(activities),\n    })\n  }\n\n  filterActivities = (predicate = activity => true) => {\n    const filtered = this.state.activities.filter(predicate)\n\n    this.setState({\n      activities: this._storedList.update(filtered),\n    })\n  }\n\n  clearActivities = () => {\n    // Clear all non pending activities\n    // (we don't clear pending because we're awaiting state change)\n    this.filterActivities(\n      ({ status, from }) => status === ACTIVITY_STATUS_PENDING\n    )\n  }\n\n  clearActivity = transactionHash => {\n    this.filterActivities(\n      activity => activity.transactionHash !== transactionHash\n    )\n  }\n\n  markActivitiesRead = () => {\n    // Mark the current user's activities as read\n    const readActivities = this.state.activities.map(activity => ({\n      ...activity,\n      read: true,\n    }))\n\n    this.setState({\n      activities: this._storedList.update(readActivities),\n    })\n  }\n\n  // update activity status and set the activity to unread\n  setActivityStatus = status => transactionHash => {\n    const activities = this.state.activities.map(activity =>\n      activity.transactionHash === transactionHash\n        ? {\n            ...activity,\n            read: false,\n            status,\n          }\n        : activity\n    )\n\n    this.setState({\n      activities: this._storedList.update(activities),\n    })\n  }\n\n  setActivityConfirmed = this.setActivityStatus(ACTIVITY_STATUS_CONFIRMED)\n  setActivityFailed = this.setActivityStatus(ACTIVITY_STATUS_FAILED)\n  setActivityTimedOut = this.setActivityStatus(ACTIVITY_STATUS_TIMED_OUT)\n\n  setActivityNonce = ({ transactionHash, nonce }) => {\n    const activities = this.state.activities.map(activity =>\n      activity.transactionHash === transactionHash\n        ? {\n            ...activity,\n            nonce,\n          }\n        : activity\n    )\n\n    this.setState({\n      activities: this._storedList.update(activities),\n    })\n  }\n\n  getUnreadActivityCount = () =>\n    this.state.activities.reduce(\n      (count, { read }) => (read ? count : count + 1),\n      0\n    )\n\n  render() {\n    const { children } = this.props\n    const unreadActivityCount = this.getUnreadActivityCount()\n\n    return (\n      <ActivityContext.Provider\n        value={{\n          activities: this.state.activities,\n          addTransactionActivity: this.addTransactionActivity,\n          clearActivities: this.clearActivities,\n          clearActivity: this.clearActivity,\n          markActivitiesRead: this.markActivitiesRead,\n          setActivityConfirmed: this.setActivityConfirmed,\n          setActivityFailed: this.setActivityFailed,\n          setActivityNonce: this.setActivityNonce,\n          updateActivities: this.updateActivities,\n          unreadActivityCount,\n        }}\n      >\n        {children}\n      </ActivityContext.Provider>\n    )\n  }\n}\n\nfunction ActivityProvider(props) {\n  const { account, networkType } = useWallet()\n  return (\n    <ActivityProviderBase\n      networkType={networkType}\n      account={account}\n      {...props}\n    />\n  )\n}\n\nconst ActivityConsumer = ActivityContext.Consumer\n\nexport { ActivityContext, ActivityProvider, ActivityConsumer }\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = memoize;\n","import memoize from 'lodash.memoize'\nimport { addressesEqual } from './util/web3'\n\n// Note that these two terms are slightly confusing artifacts of the ACL:\n//   Any entity: If a permission is granted to \"any entity\", then any address can be seen as holding\n//               that permission\n//   Burn entity: If a role's permission manager is set as \"burn entity\", then it is assumed to be a\n//               discarded and frozen role\nexport const ANY_ENTITY = '0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF'\nconst BURN_ENTITY = '0x0000000000000000000000000000000000000001'\nconst UNASSIGNED_ENTITY = '0x0000000000000000000000000000000000000000'\nconst KERNEL_ROLES = [\n  {\n    name: 'Manage apps',\n    id: 'APP_MANAGER_ROLE',\n    params: [],\n    bytes: '0xb6d92708f3d4817afc106147d969e229ced5c46e65e0a5002a0d391287762bd0',\n  },\n]\n\nexport function getAnyEntity() {\n  return ANY_ENTITY\n}\n\nexport function getBurnEntity() {\n  return BURN_ENTITY\n}\n\nexport function getUnassignedEntity() {\n  return UNASSIGNED_ENTITY\n}\n\n// Check if the address represents ‚ÄúAny address‚Äù\nexport function isAnyEntity(address) {\n  return addressesEqual(address, ANY_ENTITY)\n}\n\n// Check if the address represents the ‚ÄúBurned address‚Äù\nexport function isBurnEntity(address) {\n  return addressesEqual(address, BURN_ENTITY)\n}\n\n// Check if the address represents an unassigned entity (either non-existent or 0x00)\nexport function isUnassignedEntity(address) {\n  return addressesEqual(address, UNASSIGNED_ENTITY)\n}\n\n// Get a role from the known roles (kernel)\nexport function getKnownRole(roleBytes) {\n  for (const role of KERNEL_ROLES) {\n    if (roleBytes === role.bytes) {\n      return { appName: 'Kernel', role }\n    }\n  }\n  return null\n}\n\n// Get a flattened list of all app permissions grouped by their roles,\n// with their assigned entities (if any)\nexport function permissionsByRole(apps, permissions) {\n  return apps\n    .map(app => {\n      const { proxyAddress: appAddress, roles = [] } = app\n      const appPermissions = permissions[appAddress] || {}\n      return roles.map(({ bytes: roleBytes }) => {\n        const rolePermissions = appPermissions[roleBytes] || {}\n        return {\n          appAddress,\n          roleBytes,\n          entities: rolePermissions.allowedEntities || [],\n          manager: rolePermissions.manager || getUnassignedEntity(),\n        }\n      })\n    })\n    .flat()\n}\n\n// Get the roles of an app.\nexport function appRoles(app, permissions) {\n  const roles = permissions[app.proxyAddress]\n  return roles\n    ? Object.entries(roles).map(\n        ([roleBytes, { allowedEntities, manager }]) => ({\n          roleBytes,\n          allowedEntities,\n          manager,\n        })\n      )\n    : []\n}\n\n// Resolves a role from its bytes to its description using the provided apps\nfunction resolveRole(apps, appAddress, roleBytes) {\n  const knownRole = getKnownRole(roleBytes)\n  if (knownRole) {\n    return knownRole.role\n  }\n  const app = apps.find(app => addressesEqual(app.proxyAddress, appAddress))\n  if (!app || !app.roles) {\n    return null\n  }\n  return app.roles.find(role => role.bytes === roleBytes)\n}\n\n// Resolves an entity using the provided apps\nfunction resolveEntity(apps, address) {\n  const entity = { address, type: 'address' }\n  if (isAnyEntity(address)) {\n    return { ...entity, type: 'any' }\n  }\n  if (isBurnEntity(address)) {\n    return { ...entity, type: 'burn' }\n  }\n  if (isUnassignedEntity(address)) {\n    return { ...entity, type: 'unassigned' }\n  }\n  const app = apps.find(app => addressesEqual(app.proxyAddress, address))\n  return app ? { ...entity, app, type: 'app' } : entity\n}\n\n// Returns a function that resolves an entity, caching the results\nexport function entityResolver(apps = []) {\n  return memoize(address => resolveEntity(apps, address))\n}\n\n// Returns a function that resolves an role, caching the results\nexport function roleResolver(apps = []) {\n  return memoize(\n    (appAddress, roleBytes) => resolveRole(apps, appAddress, roleBytes),\n    (appAddress, roleBytes) => appAddress + roleBytes\n  )\n}\n","import React, { useContext, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { AppType } from '../prop-types'\nimport {\n  appRoles,\n  entityResolver,\n  roleResolver,\n  permissionsByRole,\n} from '../permissions'\nimport { log, noop } from '../util/utils'\nimport { addressesEqual, getEmptyAddress } from '../util/web3'\n\nconst PermissionsContext = React.createContext()\n\nclass PermissionsProvider extends React.Component {\n  static propTypes = {\n    apps: PropTypes.arrayOf(AppType).isRequired,\n    children: PropTypes.node.isRequired,\n    permissions: PropTypes.object.isRequired,\n    wrapper: PropTypes.object,\n  }\n\n  state = {\n    roles: [],\n    apps: [],\n    resolveEntity: noop,\n    resolveRole: noop,\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    if (!props.apps || props.apps === state.apps) {\n      return null\n    }\n\n    return {\n      apps: props.apps,\n      resolveEntity: entityResolver(props.apps),\n      resolveRole: roleResolver(props.apps),\n    }\n  }\n\n  revokePermission = async ({ appAddress, entityAddress, roleBytes }) => {\n    const { wrapper } = this.props\n    if (wrapper === null) {\n      return\n    }\n    const transaction = await wrapper.performACLIntent('revokePermission', [\n      entityAddress,\n      appAddress,\n      roleBytes,\n    ])\n    log('revokePermission tx:', transaction)\n  }\n\n  // create a permission (= set a manager + grant a permission)\n  createPermission = async ({\n    appAddress,\n    entityAddress,\n    roleBytes = null,\n    manager,\n  }) => {\n    const { wrapper } = this.props\n    if (wrapper === null) {\n      return\n    }\n    log('createPermission', [entityAddress, appAddress, roleBytes, manager])\n    const transaction = await wrapper.performACLIntent('createPermission', [\n      entityAddress,\n      appAddress,\n      roleBytes,\n      manager,\n    ])\n    log('createPermission tx:', transaction)\n  }\n\n  grantPermission = async ({ appAddress, entityAddress, roleBytes }) => {\n    const { wrapper } = this.props\n    if (wrapper === null) {\n      return\n    }\n    const transaction = await wrapper.performACLIntent('grantPermission', [\n      entityAddress,\n      appAddress,\n      roleBytes,\n    ])\n    log('grantPermission tx:', transaction)\n  }\n\n  removePermissionManager = async ({ appAddress, roleBytes }) => {\n    const { wrapper } = this.props\n    if (wrapper === null) {\n      return\n    }\n    const transaction = await wrapper.performACLIntent(\n      'removePermissionManager',\n      [appAddress, roleBytes]\n    )\n    log('removePermissionManager tx:', transaction)\n  }\n\n  setPermissionManager = async ({ entityAddress, appAddress, roleBytes }) => {\n    const { wrapper } = this.props\n    if (wrapper === null) {\n      return\n    }\n    const transaction = await wrapper.performACLIntent('setPermissionManager', [\n      entityAddress,\n      appAddress,\n      roleBytes,\n    ])\n    log('setPermissionManager tx:', transaction)\n  }\n\n  // Get the roles of an app\n  getAppRoles = app => {\n    const { resolveRole } = this.state\n    const { permissions } = this.props\n    return app\n      ? appRoles(app, permissions).map(role => ({\n          ...role,\n          role: resolveRole(app.proxyAddress, role.roleBytes),\n        }))\n      : []\n  }\n\n  // Get the manager of a role\n  getRoleManager = (app, roleBytes) => {\n    const { resolveEntity } = this.state\n    const role = this.getAppRoles(app).find(\n      role => role.roleBytes === roleBytes\n    )\n    return resolveEntity((role && role.manager) || getEmptyAddress())\n  }\n\n  render() {\n    const { children, permissions } = this.props\n    return (\n      <PermissionsContext.Provider\n        value={{\n          ...this.state,\n          permissions,\n          getAppRoles: this.getAppRoles,\n          createPermission: this.createPermission,\n          getRoleManager: this.getRoleManager,\n          grantPermission: this.grantPermission,\n          removePermissionManager: this.removePermissionManager,\n          revokePermission: this.revokePermission,\n          setPermissionManager: this.setPermissionManager,\n        }}\n      >\n        {children}\n      </PermissionsContext.Provider>\n    )\n  }\n}\n\nconst PermissionsConsumer = PermissionsContext.Consumer\n\nfunction usePermissions() {\n  return useContext(PermissionsContext)\n}\n\nfunction usePermissionsByRole() {\n  const { apps, permissions, resolveRole, resolveEntity } = usePermissions()\n\n  return useMemo(\n    () =>\n      permissionsByRole(apps, permissions).map(\n        ({ appAddress, entities, manager, roleBytes, ...permission }) => {\n          const app = apps.find(app =>\n            addressesEqual(app.proxyAddress, appAddress)\n          )\n          return {\n            ...permission,\n            app: app || null,\n            entities: entities.map(resolveEntity),\n            manager: resolveEntity(manager),\n            role: resolveRole(appAddress, roleBytes),\n          }\n        }\n      ),\n    [apps, permissions, resolveRole, resolveEntity]\n  )\n}\n\nexport {\n  PermissionsProvider,\n  PermissionsConsumer,\n  usePermissions,\n  usePermissionsByRole,\n}\n","import React, { useCallback, useEffect, useRef, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Button,\n  EscapeOutside,\n  GU,\n  Modal,\n  TextInput,\n  textStyle,\n  useTheme,\n  useViewport,\n} from '@aragon/ui'\nimport IdentityBadgeWithNetwork from '../IdentityBadge/IdentityBadgeWithNetwork'\nimport keycodes from '../../keycodes'\nimport { EthereumAddressType } from '../../prop-types'\n\nfunction LocalModal({ address, label, onCancel, onDelete, onSave }) {\n  const [action, setAction] = useState(null)\n  const [error, setError] = useState(null)\n  const labelInput = useRef(null)\n\n  const { above } = useViewport()\n  const theme = useTheme()\n\n  const handleCancel = useCallback(() => {\n    onCancel()\n  }, [onCancel])\n\n  const handleSave = useCallback(() => {\n    try {\n      const label = labelInput.current.value.trim()\n      if (label) {\n        onSave({ address, label })\n      } else {\n        onDelete([address])\n      }\n    } catch (e) {\n      setError(e)\n    }\n  }, [address, labelInput, onDelete, onSave])\n\n  const handleKeyDown = useCallback(\n    e => {\n      if (e.keyCode === keycodes.enter) {\n        handleSave()\n      } else if (e.keyCode === keycodes.esc) {\n        handleCancel()\n      }\n    },\n    [handleCancel, handleSave]\n  )\n\n  useEffect(() => {\n    setAction(label && label.trim() ? 'Edit' : 'Add')\n\n    labelInput.current.focus()\n    labelInput.current.select()\n\n    window.addEventListener('keydown', handleKeyDown)\n\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [label, labelInput, handleKeyDown])\n\n  return (\n    <EscapeOutside onEscapeOutside={onCancel}>\n      <div\n        css={`\n          background: ${theme.surface};\n          max-width: calc(100vw - ${4 * GU}px);\n\n          ${above('medium') &&\n            `\n              /* wide identity badge + paddings */\n              min-width: ${54 * GU}px;\n            `};\n        `}\n      >\n        <h3\n          css={`\n            ${textStyle('title4')};\n          `}\n        >\n          {action} custom label\n        </h3>\n        <p\n          css={`\n            margin: ${5 * GU}px 0;\n          `}\n        >\n          This label would be displayed instead of the following address and\n          only be <strong>stored on this device</strong>.\n        </p>\n        <IdentityBadgeWithNetwork entity={address} />\n        <Label>\n          <div>Custom Label</div>\n          <TextInput\n            wide\n            defaultValue={label}\n            ref={labelInput}\n            maxLength=\"42\"\n          />\n          <div\n            css={`\n              color: ${theme.negative};\n              text-transform: initial;\n            `}\n          >\n            {error}\n          </div>\n        </Label>\n        <div\n          css={`\n            display: grid;\n            grid-gap: ${1 * GU}px;\n            grid-template-columns: 1fr 1fr;\n            ${above('medium') &&\n              `\n                display: flex;\n                justify-content: flex-end;\n              `};\n          `}\n        >\n          <Button\n            onClick={handleCancel}\n            css={`\n              min-width: ${8 * GU}px;\n            `}\n          >\n            Cancel\n          </Button>\n          <Button\n            mode=\"strong\"\n            onClick={handleSave}\n            css={`\n              min-width: ${8 * GU}px;\n              ${above('medium') &&\n                `\n                  margin-left: ${2 * GU}px;\n                `}\n            `}\n          >\n            Save\n          </Button>\n        </div>\n      </div>\n    </EscapeOutside>\n  )\n}\n\nLocalModal.propTypes = {\n  address: EthereumAddressType,\n  label: PropTypes.string,\n  onCancel: PropTypes.func,\n  onDelete: PropTypes.func,\n  onSave: PropTypes.func,\n}\n\nfunction Label(props) {\n  const theme = useTheme()\n\n  return (\n    <label\n      css={`\n        display: block;\n        margin: ${3 * GU}px 0;\n        color: ${theme.surfaceContentSecondary};\n        ${textStyle('label2')};\n        & > div {\n          margin: ${1 * GU}px 0;\n        }\n      `}\n      {...props}\n    />\n  )\n}\n\nexport default function LocalIdentityModal({ opened, onCancel, ...props }) {\n  return (\n    <Modal visible={opened} onClose={onCancel}>\n      <LocalModal onCancel={onCancel} {...props} />\n    </Modal>\n  )\n}\n\nLocalIdentityModal.propTypes = {\n  onCancel: PropTypes.func,\n  opened: PropTypes.bool,\n}\n","import React, { useEffect, useState, useCallback } from 'react'\nimport styled from 'styled-components'\nimport { AragonType } from '../../../prop-types'\nimport {\n  Box,\n  Button,\n  Info,\n  GU,\n  TextInput,\n  textStyle,\n  useLayout,\n  useTheme,\n} from '@aragon/ui'\nimport { getEthNode } from '../../../environment'\nimport { InvalidNetworkType, InvalidURI, NoConnection } from '../../../errors'\nimport {\n  setDefaultEthNode,\n  setIpfsGateway,\n  getIpfsGateway,\n} from '../../../local-settings'\nimport keycodes from '../../../keycodes'\nimport { sanitizeNetworkType } from '../../../util/network'\nimport { checkValidEthNode } from '../../../util/web3'\nimport { useWallet } from '../../../contexts/wallet'\nimport { trackEvent, events } from '../../../analytics'\n\nfunction Network({ wrapper }) {\n  const {\n    ethNode,\n    ipfsGateway,\n    handleNetworkChange,\n    handleClearCache,\n    networkError,\n    handleEthNodeChange,\n    handleIpfsGatewayChange,\n    networkType,\n  } = useNetwork(wrapper)\n  const theme = useTheme()\n  const { layoutName } = useLayout()\n  const compact = layoutName === 'small'\n\n  return (\n    <React.Fragment>\n      <Box heading=\"Node settings\">\n        <Label theme={theme}>\n          Ethereum node\n          <TextInput\n            value={ethNode}\n            wide\n            onChange={handleEthNodeChange}\n            css={`\n              ${textStyle('body2')};\n              color: ${theme.contentSecondary};\n              ${networkError ? `border-color: ${theme.negative};` : ''}\n            `}\n          />\n          {networkError && (\n            <span\n              css={`\n                ${textStyle('body4')};\n                color: ${theme.negative};\n              `}\n            >\n              {(() => {\n                if (networkError instanceof InvalidNetworkType) {\n                  return `Node must be connected to ${sanitizeNetworkType(\n                    networkType\n                  )}`\n                }\n                if (networkError instanceof InvalidURI) {\n                  return 'Must provide WebSocket endpoint to node'\n                }\n                if (networkError instanceof NoConnection) {\n                  return 'Could not connect to node'\n                }\n                return 'URI does not seem to be a ETH node'\n              })()}\n            </span>\n          )}\n        </Label>\n        <Label theme={theme}>\n          IPFS Gateway\n          <TextInput\n            value={ipfsGateway}\n            wide\n            onChange={handleIpfsGatewayChange}\n            css={`\n              ${textStyle('body2')};\n              color: ${theme.contentSecondary};\n            `}\n          />\n        </Label>\n        <Button mode=\"strong\" onClick={handleNetworkChange} wide={compact}>\n          Save changes\n        </Button>\n      </Box>\n      <Box heading=\"Troubleshooting\">\n        <div\n          css={`\n            margin-bottom: ${2 * GU}px;\n          `}\n        >\n          <span>\n            Press this button to refresh the cache of the application in your\n            browser.\n          </span>\n        </div>\n        <Button\n          css={`\n            margin-bottom: ${2 * GU}px;\n          `}\n          onClick={handleClearCache}\n          wide={compact}\n        >\n          Clear application cache\n        </Button>\n        <Info>\n          This will only delete the data stored in your browser to make the app\n          load faster. No data related to the organization itself will be\n          altered.\n        </Info>\n      </Box>\n    </React.Fragment>\n  )\n}\n\nNetwork.propTypes = {\n  wrapper: AragonType,\n}\n\nconst useNetwork = wrapper => {\n  const { networkType } = useWallet()\n  const [networkError, setNetworkError] = useState(null)\n  const [ethNode, setEthNodeValue] = useState(getEthNode(networkType))\n  const [ipfsGateway, setIpfsGatewayValue] = useState(getIpfsGateway())\n\n  const handleNetworkChange = useCallback(async () => {\n    try {\n      await checkValidEthNode(ethNode, networkType)\n    } catch (err) {\n      setNetworkError(err)\n      return\n    }\n\n    setDefaultEthNode(ethNode, networkType)\n    setIpfsGateway(ipfsGateway, networkType)\n    // For now, we have to reload the page to propagate the changes\n    window.location.reload()\n\n    // analytics\n    trackEvent(events.USER_NETWORK_SETTINGS_SAVED, {\n      settings: { ethNode: ethNode, ipfsGateway: ipfsGateway },\n      network: networkType,\n    })\n  }, [ethNode, ipfsGateway, networkType])\n  const handleClearCache = useCallback(async () => {\n    if (wrapper) {\n      await wrapper.cache.clear()\n    }\n    window.localStorage.clear()\n    window.location.reload()\n\n    // analytics\n    trackEvent(events.CACHE_CLEARED, {\n      network: networkType,\n    })\n  }, [wrapper, networkType])\n  const handleKeyPress = useCallback(\n    ({ keyCode }) => {\n      const defaultEthNode = getEthNode(networkType)\n      const defaultIpfsGateway = getIpfsGateway()\n      if (\n        keyCode === keycodes.enter &&\n        (ipfsGateway !== defaultIpfsGateway || ethNode !== defaultEthNode)\n      ) {\n        handleNetworkChange()\n      }\n    },\n    [handleNetworkChange, ethNode, ipfsGateway, networkType]\n  )\n\n  useEffect(() => {\n    window.addEventListener('keypress', handleKeyPress)\n    return () => window.removeEventListener('keypress', handleKeyPress)\n  }, [handleKeyPress])\n\n  return {\n    ethNode,\n    networkType,\n    ipfsGateway,\n    handleNetworkChange,\n    handleClearCache,\n    networkError,\n    handleEthNodeChange: ({ currentTarget: { value } }) =>\n      setEthNodeValue(value),\n    handleIpfsGatewayChange: ({ currentTarget: { value } }) =>\n      setIpfsGatewayValue(value),\n  }\n}\n\nconst Label = styled.label`\n  color: ${({ theme }) => theme.content};\n  display: block;\n  margin-bottom: ${2 * GU}px;\n`\n\nexport default React.memo(Network)\n","import { extendError } from '../../../errors'\n\nconst NOTIFICATION_SERVICE_URL = 'https://notifications.eth.aragon.network'\nexport const NOTIFICATION_SERVICE_ACCOUNT = `${NOTIFICATION_SERVICE_URL}/account`\nexport const NOTIFICATION_SERVICE_LOGIN = `${NOTIFICATION_SERVICE_URL}/login`\nexport const NOTIFICATION_SERVICE_VERIFY = `${NOTIFICATION_SERVICE_URL}/verify`\nexport const NOTIFICATION_SERVICE_SUBSCRIPTIONS = `${NOTIFICATION_SERVICE_URL}/subscriptions`\n\nexport const NOTIFICATION_SERVICE_HAS_LOGGED_OUT_KEY =\n  'NOTIFICATION_SERVICE_HAS_LOGGED_OUT_KEY'\nexport const NOTIFICATION_SERVICE_EMAIL_KEY = 'NOTIFICATION_SERVICE_EMAIL_KEY'\nexport const NOTIFICATION_SERVICE_TOKEN_KEY = 'NOTIFICATION_SERVICE_TOKEN_KEY'\nexport const VERIFY_SUBSECTION = '/verify/'\n\n// A user can be in one of these three states\n// Only once the user is verified (authenticated) can he create subscriptions\nexport const AUTH_UNAUTHENTICATED = Symbol('AUTH_UNAUTHENTICATED')\nexport const AUTH_PREVERIFY = Symbol('AUTH_PREVERIFY') // submitted email but didn't verify\nexport const AUTH_AUTHENTICATING = Symbol('AUTH_AUTHENTICATING')\nexport const AUTH_SERVICE_UNAVAILABLE = Symbol('AUTH_SERVICE_UNAVAILABLE')\nexport const AUTH_AUTHENTICATED = Symbol('AUTH_AUTHENTICATED')\nexport const AUTH_AUTHENTICATION_FAILED = Symbol('AUTH_AUTHENTICATION_FAILED')\n\nexport const API_MESSAGE_EXPIRED_TOKEN = 'Expired token'\n\nexport const ExpiredTokenError = extendError('ExpiredToken', {\n  defaultMessage: 'Notification Service API token has expired',\n})\n\nexport const UnauthorizedError = extendError('UnauthorizedError', {\n  defaultMessage: 'Notification Service API unauthorized',\n})\n\nexport const SUCCESSFUL_VERIFICATION_REDIRECTION_DELAY = 10 * 1000\n\nexport const CREATE_SUBSCRIPTION_REQUIRED_KEYS = [\n  'appName',\n  'eventName',\n  'contractAddress',\n  'ensName',\n  'network',\n  'abi',\n]\n","import { isOnEthMainnet } from '../../../util/network'\nimport {\n  NOTIFICATION_SERVICE_ACCOUNT,\n  NOTIFICATION_SERVICE_LOGIN,\n  NOTIFICATION_SERVICE_VERIFY,\n  NOTIFICATION_SERVICE_SUBSCRIPTIONS,\n  API_MESSAGE_EXPIRED_TOKEN,\n  ExpiredTokenError,\n  UnauthorizedError,\n} from './constants'\n\n// The notifications API expects mainnet for Ethereum mainnet. This deviates from deviates\n// from networkType returned from use-wallet that returns main instead of mainnet\nconst sanitizeNetworkType = networkType =>\n  isOnEthMainnet(networkType) ? 'mainnet' : networkType\n\nconst isAuthTokenExpired = response =>\n  response.statusCode === 401 && response.message === API_MESSAGE_EXPIRED_TOKEN\n\nconst isUnauthorized = rawResponse => rawResponse.status === 401\n\nexport const login = async ({ networkType, email, dao }) => {\n  try {\n    const rawResponse = await fetch(NOTIFICATION_SERVICE_LOGIN, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        email,\n        dao,\n        network: sanitizeNetworkType(networkType),\n      }),\n    })\n    if (!rawResponse.ok) {\n      throw new Error(rawResponse.statusText)\n    }\n  } catch (e) {\n    console.error(e)\n    throw e\n  }\n}\n\n// Verify the short lived email token and fetch a long lived token\nexport async function verifyEmailToken(shortLivedToken) {\n  try {\n    const rawResponse = await fetch(NOTIFICATION_SERVICE_VERIFY, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        authorization: shortLivedToken,\n      },\n    })\n\n    if (rawResponse.ok) {\n      return rawResponse.headers.get('authorization')\n    }\n\n    // In case of errors the api will return json payload\n    const response = await rawResponse.json()\n\n    if (isAuthTokenExpired(response)) {\n      throw new ExpiredTokenError(response.message)\n    }\n\n    if (isUnauthorized(rawResponse)) {\n      throw new UnauthorizedError(rawResponse.statusText)\n    }\n\n    throw new Error(rawResponse.statusText)\n\n    // Get the long lived token from header\n  } catch (e) {\n    console.error(e.message)\n    throw e\n  }\n}\n\n// Verify that the long lived token is valid and has not expired\nexport async function isAuthTokenValid(longLivedToken) {\n  try {\n    const rawResponse = await fetch(NOTIFICATION_SERVICE_ACCOUNT, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        authorization: longLivedToken,\n      },\n    })\n\n    if (rawResponse.ok) {\n      return rawResponse\n    }\n\n    // In case of errors the api will return json payload\n    const response = await rawResponse.json()\n\n    if (isAuthTokenExpired(response)) {\n      throw new ExpiredTokenError(response.message)\n    }\n\n    if (isUnauthorized(rawResponse)) {\n      throw new UnauthorizedError(rawResponse.statusText)\n    }\n\n    throw new Error(rawResponse.statusText)\n  } catch (e) {\n    console.error(e.message)\n    throw e\n  }\n}\n\n/**\n * Delete a user account\n *\n * @param {string} token long lived api token\n * @returns {Number} 1 if the account was deleted successfully\n */\nexport async function deleteAccount(token) {\n  try {\n    const rawResponse = await fetch(NOTIFICATION_SERVICE_ACCOUNT, {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n        authorization: token,\n      },\n    })\n\n    const response = await rawResponse.json()\n\n    if (!rawResponse.ok) {\n      // In case of errors the api will return json payload\n      if (isAuthTokenExpired(response)) {\n        throw new ExpiredTokenError(response.message)\n      }\n\n      if (isUnauthorized(rawResponse)) {\n        throw new UnauthorizedError(rawResponse.statusText)\n      }\n\n      throw new Error(rawResponse.statusText)\n    }\n\n    return response\n  } catch (e) {\n    console.error(e.message)\n    throw e\n  }\n}\n\n/**\n * Delete multiple subscriptionds\n *\n * @param {Object}    options to delete\n * @param {String[]}  options.subscriptionIds to delete\n * @param {String}    options.token long lived api token\n *\n * @returns {Number} Count of deleted subscriptions\n */\nexport async function deleteSubscriptions({ subscriptionIds, authToken } = {}) {\n  try {\n    const rawResponse = await fetch(NOTIFICATION_SERVICE_SUBSCRIPTIONS, {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n        authorization: authToken,\n      },\n      body: JSON.stringify({ subscriptions: subscriptionIds }),\n    })\n\n    const response = await rawResponse.json()\n\n    if (!rawResponse.ok) {\n      // In case of errors the api will return json payload\n      if (isAuthTokenExpired(response)) {\n        throw new ExpiredTokenError(response.message)\n      }\n\n      if (isUnauthorized(rawResponse)) {\n        throw new UnauthorizedError(rawResponse.statusText)\n      }\n\n      throw new Error(rawResponse.statusText)\n    }\n\n    return response\n  } catch (e) {\n    console.error(e.message)\n    throw e\n  }\n}\n\nexport async function getSubscriptions(networkType, token) {\n  const url = new URL(NOTIFICATION_SERVICE_SUBSCRIPTIONS)\n  url.searchParams.append('network', sanitizeNetworkType(networkType))\n\n  try {\n    const rawResponse = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        authorization: token,\n      },\n    })\n\n    const response = await rawResponse.json()\n\n    if (isAuthTokenExpired(response)) {\n      throw new ExpiredTokenError(response.message)\n    }\n\n    if (isUnauthorized(rawResponse)) {\n      throw new UnauthorizedError(rawResponse.statusText)\n    }\n\n    if (!rawResponse.ok) {\n      throw new Error(response.statusText)\n    }\n\n    return response\n  } catch (e) {\n    console.error(e)\n    throw e\n  }\n}\n\n/**\n * Create subscription\n *\n * @param {Object} options options object\n * @param {string} options.token api token\n * @param {string} options.appName appName aka the ens name of the APM repo\n * @param {string} options.eventName event name as defined in the ABI\n * @param {string} options.contractAddress address of the proxy contract\n * @param {string} options.ensName ens name of the DAO with the app installed\n * @param {object} options.abi abi of the appName\n *\n * @returns {Promise} Promise that resolves with response body if successful\n */\nexport const createSubscription = async ({\n  abi,\n  appName,\n  appContractAddress,\n  ensName,\n  eventName,\n  token,\n  networkType,\n} = {}) => {\n  try {\n    const rawResponse = await fetch(NOTIFICATION_SERVICE_SUBSCRIPTIONS, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        authorization: token,\n      },\n      body: JSON.stringify({\n        appName,\n        eventName,\n        ensName,\n        abi,\n        contractAddress: appContractAddress,\n        network: sanitizeNetworkType(networkType),\n      }),\n    })\n\n    const response = await rawResponse.json()\n\n    if (isAuthTokenExpired(response)) {\n      throw new ExpiredTokenError(response.message)\n    }\n\n    if (isUnauthorized(rawResponse)) {\n      throw new UnauthorizedError(rawResponse.statusText)\n    }\n\n    if (!rawResponse.ok) {\n      throw new Error(rawResponse.statusText)\n    }\n\n    return response\n  } catch (e) {\n    console.error(e)\n    throw e\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Tag, GU } from '@aragon/ui'\n\nfunction LocalLabelPopoverTitle({ label }) {\n  return (\n    <div\n      css={`\n        display: grid;\n        align-items: center;\n        grid-template-columns: auto 1fr;\n      `}\n    >\n      <span\n        css={`\n          display: inline-block;\n          overflow: hidden;\n          text-overflow: ellipsis;\n          white-space: nowrap;\n        `}\n      >\n        {label}\n      </span>\n      <Tag\n        mode=\"identifier\"\n        css={`\n          margin-left: ${2 * GU}px;\n        `}\n      >\n        Custom label\n      </Tag>\n    </div>\n  )\n}\nLocalLabelPopoverTitle.propTypes = {\n  label: PropTypes.string.isRequired,\n}\n\nexport default LocalLabelPopoverTitle\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { IconLabel, GU } from '@aragon/ui'\n\nfunction LocalLabelPopoverActionLabel({ hasLabel }) {\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n      `}\n    >\n      <IconLabel\n        css={`\n          margin-right: ${1 * GU}px;\n        `}\n      />\n      {hasLabel ? 'Edit' : 'Add'} custom label\n    </div>\n  )\n}\nLocalLabelPopoverActionLabel.propTypes = {\n  hasLabel: PropTypes.bool,\n}\n\nexport default LocalLabelPopoverActionLabel\n","import React, { useContext, useCallback, useEffect, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { AppBadge, GU, Tag } from '@aragon/ui'\nimport { useLocalIdentity } from '../../hooks'\nimport { AppType } from '../../prop-types'\nimport iconSvgAcl from '../AppIcon/assets/app-acl.svg'\nimport iconSvgKernel from '../AppIcon/assets/app-kernel.svg'\nimport iconSvgRegistry from '../AppIcon/assets/app-registry.svg'\nimport LocalLabelPopoverTitle from './LocalLabelPopoverTitle'\nimport LocalLabelPopoverActionLabel from './LocalLabelPopoverActionLabel'\nimport { LocalIdentityModalContext } from '../LocalIdentityModal/LocalIdentityModalManager'\nimport {\n  IdentityContext,\n  identityEventTypes,\n} from '../IdentityManager/IdentityManager'\n\nconst KNOWN_ICONS = new Map([\n  [\n    '0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c',\n    iconSvgKernel,\n  ],\n  [\n    '0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61',\n    iconSvgRegistry,\n  ],\n  [\n    '0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a',\n    iconSvgAcl,\n  ],\n])\n\nconst LocalLabelAppBadge = React.memo(function LocalLabelAppBadge({\n  apps,\n  app,\n  noIdentifier,\n  ...props\n}) {\n  const {\n    appId,\n    baseUrl,\n    name: appName,\n    icons = [],\n    identifier,\n    proxyAddress,\n  } = app\n  const [label, setLabel] = useState(appName)\n  const { name, handleResolve } = useLocalIdentity(proxyAddress)\n  const { showLocalIdentityModal } = useContext(LocalIdentityModalContext)\n  const { identityEvents$ } = useContext(IdentityContext)\n  const onlyOneInstance = apps.filter(a => a.appId === appId).length === 1\n\n  useEffect(() => {\n    setLabel(name || appName)\n  }, [appName, name])\n\n  const handleClick = useCallback(() => {\n    showLocalIdentityModal(proxyAddress)\n      .then(handleResolve)\n      .then(() =>\n        identityEvents$.next({\n          type: identityEventTypes.MODIFY,\n          address: proxyAddress,\n        })\n      )\n      .catch(e => {\n        /* user cancelled modify intent */\n      })\n  }, [proxyAddress, identityEvents$, handleResolve, showLocalIdentityModal])\n\n  const { src: iconSrc } = icons[0] || {}\n\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n      `}\n    >\n      <AppBadge\n        appAddress={proxyAddress}\n        label={label}\n        iconSrc={iconSrc ? `${baseUrl}${iconSrc}` : KNOWN_ICONS.get(appId)}\n        {...props}\n        popoverAction={{\n          label: <LocalLabelPopoverActionLabel hasLabel={Boolean(label)} />,\n          onClick: handleClick,\n        }}\n        popoverTitle={\n          label ? <LocalLabelPopoverTitle label={label} /> : undefined\n        }\n      />\n      {!onlyOneInstance && !noIdentifier && !name && (\n        <Tag\n          mode=\"identifier\"\n          css={`\n            margin-left: ${1 * GU}px;\n          `}\n        >\n          {identifier}\n        </Tag>\n      )}\n    </div>\n  )\n})\n\nLocalLabelAppBadge.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  app: AppType.isRequired,\n  noIdentifier: PropTypes.bool,\n}\n\nexport default LocalLabelAppBadge\n","import React, { useEffect, useState, useCallback } from 'react'\nimport {\n  Box,\n  Button,\n  DropDown,\n  GU,\n  IconMail,\n  LoadingRing,\n  textStyle,\n  useLayout,\n  useTheme,\n} from '@aragon/ui'\nimport { AppType } from '../../../prop-types'\nimport { useRouting } from '../../../routing'\nimport PropTypes from 'prop-types'\nimport memoize from 'lodash.memoize'\nimport styled from 'styled-components'\nimport { createSubscription } from './notification-service-api'\nimport notificationImage from './notification.png'\nimport LocalLabelAppBadge from '../../LocalLabelAppBadge/LocalLabelAppBadge'\nimport { useWallet } from '../../../contexts/wallet'\n\nconst getEventNamesFromAbi = memoize(abi =>\n  abi.filter(item => item.type === 'event').map(item => item.name)\n)\n\nconst filterSubscribedEvents = (abiEvents, subscribedEvents) =>\n  abiEvents.filter(\n    eventName =>\n      !subscribedEvents.includes(eventName) &&\n      // Ignore rare / internal events\n      eventName !== 'ScriptResult' &&\n      eventName !== 'RecoverToVault'\n  )\n\n// Get subscribable events for the contractAddress from the ABI and filter out existing subscriptions\nfunction getSubscribableEvents({ subscriptions, abi, contractAddress } = {}) {\n  const subscribedEvents = subscriptions\n    .filter(subscription => subscription.contractAddress === contractAddress)\n    .map(({ eventName }) => eventName)\n\n  const abiEvents = getEventNamesFromAbi(abi)\n  return filterSubscribedEvents(abiEvents, subscribedEvents)\n}\n\nfunction getSubscribables(apps, subscriptions) {\n  const subscribableApps = apps.filter(\n    app =>\n      !app.isAragonOsInternalApp &&\n      getSubscribableEvents({\n        subscriptions,\n        abi: app.abi,\n        contractAddress: app.proxyAddress,\n      }).length > 0 // When subscribed to all events of an app, filter out apps with no subscribable events\n  )\n  const subscribableEvents = subscribableApps.map(app =>\n    getSubscribableEvents({\n      subscriptions,\n      abi: app.abi,\n      contractAddress: app.proxyAddress,\n    })\n  )\n\n  return [subscribableApps, subscribableEvents]\n}\n\nexport default function SubscriptionsForm({\n  apps,\n  isFetchingSubscriptions,\n  onApiError,\n  fetchSubscriptions,\n  subscriptions,\n  token,\n}) {\n  const theme = useTheme()\n  const { layoutName } = useLayout()\n  const { mode } = useRouting()\n  const { orgAddress } = mode\n  const { networkType } = useWallet()\n\n  const [selectedAppIdx, setSelectedAppIdx] = useState(-1)\n  const [selectedEventIdx, setSelectedEventIdx] = useState(-1)\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [subscribableApps, setSubscribableApps] = useState([])\n  const [subscribableEvents, setSubscribableEvents] = useState([])\n\n  const selectedApp =\n    selectedAppIdx === -1 ? null : subscribableApps[selectedAppIdx]\n  const eventNames = selectedApp ? subscribableEvents[selectedAppIdx] : ['']\n\n  const handleAppChange = useCallback(index => {\n    setSelectedAppIdx(index)\n    setSelectedEventIdx(-1)\n  }, [])\n\n  const handleEventChange = useCallback(index => {\n    setSelectedEventIdx(index)\n  }, [])\n\n  const handleSubscribe = useCallback(\n    async e => {\n      setIsSubmitting(true)\n      const { abi, appName, proxyAddress } = selectedApp\n      const eventName = eventNames[selectedEventIdx]\n      const abiEventSubset = abi.filter(({ name, type }) => type === 'event')\n\n      try {\n        const payload = {\n          abi: abiEventSubset,\n          appName,\n          appContractAddress: proxyAddress,\n          ensName: orgAddress,\n          eventName,\n          token,\n          networkType,\n        }\n        await createSubscription(payload)\n        setSelectedEventIdx(-1)\n\n        await fetchSubscriptions()\n      } catch (e) {\n        onApiError(e)\n      }\n      setIsSubmitting(false)\n    },\n    [\n      eventNames,\n      fetchSubscriptions,\n      onApiError,\n      orgAddress,\n      selectedApp,\n      selectedEventIdx,\n      token,\n      networkType,\n    ]\n  )\n  useEffect(() => {\n    const [newSubscribableApps, newSubscribableEvents] = getSubscribables(\n      apps,\n      subscriptions\n    )\n    if (\n      !newSubscribableApps[selectedAppIdx] || // case 1: selection is no longer valid\n      (subscribableApps[selectedAppIdx] && // case 2: The selection has changed due to a new array of subscribable apps\n        newSubscribableApps[selectedAppIdx].proxyAddress !==\n          subscribableApps[selectedAppIdx].proxyAddress)\n    ) {\n      // Reset the app if the selected app is no longer unavailable\n      setSelectedAppIdx(-1)\n    }\n\n    setSubscribableApps(newSubscribableApps)\n    setSubscribableEvents(newSubscribableEvents)\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [apps, subscriptions])\n\n  // Every DAO must have apps, if apps.length is 0, the DAO is still loading\n  if (apps.length === 0) {\n    return (\n      <SubscriptionsFormBox>\n        <div\n          css={`\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: ${25 * GU}px;\n          `}\n        >\n          <LoadingRing />\n          <p\n            css={`\n              margin-left: ${GU}px;\n              ${textStyle('body1')};\n            `}\n          >\n            Loading‚Ä¶\n          </p>\n        </div>\n      </SubscriptionsFormBox>\n    )\n  }\n\n  if (\n    !isFetchingSubscriptions &&\n    subscribableApps.length === 0 &&\n    apps.length > 0\n  ) {\n    return (\n      <SubscriptionsFormBox>\n        <div\n          css={`\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n          `}\n        >\n          <img\n            src={notificationImage}\n            alt=\"\"\n            height=\"193\"\n            css={`\n              display: block;\n              margin: 0 auto ${3 * GU}px;\n            `}\n          />\n          You have subscribed to all app events available on this organization!\n        </div>\n      </SubscriptionsFormBox>\n    )\n  }\n\n  const appLabels = subscribableApps.map(app => {\n    return <LocalLabelAppBadge app={app} apps={apps} badgeOnly compact />\n  })\n  const isSubscribeDisabled =\n    selectedAppIdx === -1 || selectedEventIdx === -1 || isSubmitting\n\n  return (\n    <SubscriptionsFormBox>\n      <div\n        css={`\n          margin-bottom: ${2 * GU}px;\n        `}\n      >\n        <Label\n          css={`\n            color: ${theme.surfaceContentSecondary};\n          `}\n        >\n          App\n        </Label>\n        <DropDown\n          wide\n          header=\"App\"\n          placeholder=\"Select an App\"\n          items={appLabels}\n          selected={selectedAppIdx}\n          onChange={handleAppChange}\n        />\n      </div>\n      <div>\n        <Label\n          css={`\n            color: ${theme.surfaceContentSecondary};\n          `}\n        >\n          Event\n        </Label>\n        <DropDown\n          disabled={selectedAppIdx === -1}\n          placeholder=\"Select an Event\"\n          width=\"100%\"\n          items={eventNames}\n          selected={selectedEventIdx}\n          onChange={handleEventChange}\n        />\n      </div>\n      <div\n        css={`\n          margin-top: ${4 * GU}px;\n        `}\n      >\n        <Button\n          mode=\"strong\"\n          wide={layoutName === 'small'}\n          disabled={isSubscribeDisabled}\n          onClick={handleSubscribe}\n        >\n          {isSubmitting ? (\n            <LoadingRing\n              css={`\n                margin-right: ${GU}px;\n              `}\n            />\n          ) : (\n            <IconMail\n              css={`\n                color: ${isSubscribeDisabled\n                  ? theme.disabledIcon\n                  : theme.accentContent};\n                margin-right: ${GU}px;\n              `}\n            />\n          )}{' '}\n          Subscribe\n        </Button>\n      </div>\n    </SubscriptionsFormBox>\n  )\n}\n\nSubscriptionsForm.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  isFetchingSubscriptions: PropTypes.bool,\n  onApiError: PropTypes.func,\n  fetchSubscriptions: PropTypes.func,\n  subscriptions: PropTypes.array,\n  token: PropTypes.string,\n}\n\nconst SubscriptionsFormBox = props => {\n  return <Box heading=\"Create Subscriptions\" {...props} />\n}\n\nconst Label = styled.label`\n  display: block;\n  margin-bottom: ${GU}px;\n`\n","import React, { useState, useEffect } from 'react'\nimport { Button, DropDown, GU, Tag, useLayout } from '@aragon/ui'\nimport PropTypes from 'prop-types'\nimport { AppType } from '../../../prop-types'\nimport { useLocalIdentity } from '../../../hooks'\n\nconst AppLabel = React.memo(function AppLabel({ apps, app }) {\n  const { name: appName, proxyAddress, contractAddress, identifier } = app\n  const [label, setLabel] = useState(appName)\n  const { name } = useLocalIdentity(proxyAddress)\n  const onlyOneInstance =\n    apps.filter(a => a.contractAddress === contractAddress).length === 1\n\n  useEffect(() => {\n    setLabel(name || appName)\n  }, [appName, name])\n\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n      `}\n    >\n      {label}\n      {!onlyOneInstance && !name && (\n        <Tag\n          mode=\"identifier\"\n          css={`\n            margin-left: ${1 * GU}px;\n          `}\n        >\n          {identifier}\n        </Tag>\n      )}\n    </div>\n  )\n})\n\nAppLabel.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  app: AppType.isRequired,\n}\n\nfunction SubscriptionFilters({\n  organizations,\n  selectedOrganization,\n  onOrganizationChange,\n  apps,\n  appsFull,\n  selectedApp,\n  onAppChange,\n  events,\n  selectedEvent,\n  onEventChange,\n  onClearFilters,\n}) {\n  const { layoutName } = useLayout()\n  const compact = layoutName === 'small'\n  const appLabels = apps.map(appName => {\n    const app = appsFull.find(app => app.appName === appName)\n    if (!app) {\n      return appName\n    }\n\n    return app.name\n  })\n\n  return (\n    <div\n      css={`\n        width: 100%;\n        margin-bottom: ${1 * GU}px;\n        display: inline-grid;\n        grid-gap: ${1.5 * GU}px;\n        grid-template-columns: ${compact ? 'auto' : 'auto auto auto auto'};\n        grid-template-rows: ${compact ? 'auto auto auto auto' : 'auto'};\n      `}\n    >\n      <DropDown\n        placeholder=\"Organization\"\n        header=\"Organization\"\n        items={organizations}\n        selected={selectedOrganization}\n        onChange={onOrganizationChange}\n      />\n      <DropDown\n        placeholder=\"App\"\n        header=\"App\"\n        items={appLabels}\n        selected={selectedApp}\n        onChange={onAppChange}\n      />\n      <DropDown\n        placeholder=\"Event\"\n        header=\"Event\"\n        items={events}\n        selected={selectedEvent}\n        onChange={onEventChange}\n      />\n      <Button\n        css={`\n          justify-self: end;\n          opacity: ${selectedOrganization !== -1 ||\n          selectedApp !== -1 ||\n          selectedEvent !== -1\n            ? 1\n            : 0};\n        `}\n        onClick={onClearFilters}\n      >\n        Clear filters\n      </Button>\n    </div>\n  )\n}\n\nSubscriptionFilters.propTypes = {\n  organizations: PropTypes.array,\n  selectedOrganization: PropTypes.number,\n  onOrganizationChange: PropTypes.func,\n  apps: PropTypes.array,\n  selectedApp: PropTypes.number,\n  onAppChange: PropTypes.func,\n  events: PropTypes.array,\n  selectedEvent: PropTypes.number,\n  onEventChange: PropTypes.func,\n  onClearFilters: PropTypes.func,\n  appsFull: PropTypes.arrayOf(AppType).isRequired,\n}\n\nexport default SubscriptionFilters\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Button, GU, Modal, textStyle, useViewport } from '@aragon/ui'\n\nexport function DeleteAccountConfirmationModal({\n  onClose,\n  onConfirm,\n  ...props\n}) {\n  const { above } = useViewport()\n\n  return (\n    <ConfirmationModal\n      {...props}\n      onClose={onClose}\n      onConfirm={onConfirm}\n      header=\"Delete your account\"\n      body=\"This action will unsubscribe you from all email notifications from all\n      organization' events.\"\n    >\n      <ModalControls large={above('medium')}>\n        <Button label=\"Cancel\" onClick={onClose}>\n          Cancel\n        </Button>\n        <RemoveButton\n          label=\"Delete Account\"\n          large={above('medium')}\n          mode=\"negative\"\n          onClick={onConfirm}\n        >\n          Delete Account\n        </RemoveButton>\n      </ModalControls>\n    </ConfirmationModal>\n  )\n}\n\nDeleteAccountConfirmationModal.propTypes = {\n  onConfirm: PropTypes.func,\n  onClose: PropTypes.func,\n  visible: PropTypes.bool,\n}\n\nexport function DeleteSubscriptionConfirmationModal({\n  onClose,\n  onConfirm,\n  ...props\n}) {\n  const { above } = useViewport()\n\n  return (\n    <ConfirmationModal\n      {...props}\n      onClose={onClose}\n      onConfirm={onConfirm}\n      header=\"Unsubscribe from email notifications\"\n      body=\"This action will unsubscribe you from the selected email notifications\n    from the organization‚Äôs events.\"\n    >\n      <ModalControls large={above('medium')}>\n        <Button label=\"Cancel\" onClick={onClose}>\n          Cancel\n        </Button>\n        <RemoveButton\n          large={above('medium')}\n          label=\"Unsubscribe\"\n          mode=\"strong\"\n          onClick={onConfirm}\n        >\n          Unsubscribe\n        </RemoveButton>\n      </ModalControls>\n    </ConfirmationModal>\n  )\n}\n\nDeleteSubscriptionConfirmationModal.propTypes = {\n  onConfirm: PropTypes.func,\n  onClose: PropTypes.func,\n  visible: PropTypes.bool,\n}\n\nfunction ConfirmationModal({ children, onClose, visible, header, body }) {\n  return (\n    <Modal css=\"z-index: 2;\" visible={visible} onClose={onClose}>\n      <h2\n        css={`\n          ${textStyle('title2')}\n        `}\n      >\n        {header}\n      </h2>\n      <p\n        css={`\n          margin-top: ${2 * GU}px;\n        `}\n      >\n        {body}\n      </p>\n\n      {children}\n    </Modal>\n  )\n}\n\nConfirmationModal.propTypes = {\n  body: PropTypes.string,\n  children: PropTypes.node,\n  header: PropTypes.string,\n  onClose: PropTypes.func,\n  visible: PropTypes.bool,\n}\n\nfunction ModalControls({ children }) {\n  const { above } = useViewport()\n\n  return (\n    <div\n      css={`\n        margin-top: ${3 * GU}px;\n        display: grid;\n        grid-gap: ${1.5 * GU}px;\n        grid-template-columns: 1fr 1fr;\n        ${above('medium') &&\n          `\n            display: flex;\n            justify-content: flex-end;\n          `}\n      `}\n    >\n      {children}\n    </div>\n  )\n}\n\nModalControls.propTypes = {\n  children: PropTypes.oneOfType([\n    PropTypes.arrayOf(PropTypes.node),\n    PropTypes.node,\n  ]),\n}\n\nfunction RemoveButton({ children, label, mode, onClick }) {\n  const { above } = useViewport()\n\n  return (\n    <Button\n      label={label}\n      mode={mode}\n      onClick={onClick}\n      css={`\n        ${above('medium') &&\n          `\n            margin-left:${1.5 * GU}px;\n          `}\n      `}\n    >\n      {children}\n    </Button>\n  )\n}\n\nRemoveButton.propTypes = {\n  children: PropTypes.node,\n  label: PropTypes.string,\n  mode: PropTypes.string,\n  onClick: PropTypes.func,\n}\n","import React, { useMemo, useState, useCallback } from 'react'\nimport styled from 'styled-components'\nimport PropTypes from 'prop-types'\nimport {\n  Button,\n  GU,\n  DataView,\n  IconMail,\n  LoadingRing,\n  useTheme,\n  textStyle,\n} from '@aragon/ui'\nimport { AppType } from '../../../prop-types'\nimport LocalIdentityBadge from '../../IdentityBadge/LocalIdentityBadge'\nimport { deleteSubscriptions } from './notification-service-api'\nimport SubscriptionFilters from './SubscriptionFilters'\nimport { DeleteSubscriptionConfirmationModal } from './NotificationModals'\nimport LocalLabelAppBadge from '../../LocalLabelAppBadge/LocalLabelAppBadge'\n\n/**\n * Filters the subscriptions based on the search criteria\n *\n * @param {Object} options options\n * @param {[Object]} options.subscriptions array of subscriptions as per the API schema\n * @param {String} options.organization organization to filter by or -1 to not search\n * @param {String} options.appName appName to filter by or -1 to not search\n * @param {String} options.event event name to filter by or -1 to not search\n *\n * @returns {[Object]} Array of filtered subscriptions\n */\nfunction filterSubscriptions({\n  subscriptions,\n  organization,\n  appName,\n  event,\n} = {}) {\n  return subscriptions.filter(subscription => {\n    const matchingOrg = organization\n      ? organization === subscription.ensName\n      : true\n    const matchingApp = appName ? appName === subscription.appName : true\n    const matchingEvent = event ? event === subscription.eventName : true\n    return matchingOrg && matchingApp && matchingEvent\n  })\n}\n\nconst DEFAULT_CONSTANT = -1\n\nconst SubscriptionsTable = React.memo(function SubscriptionsTable({\n  apps,\n  apiError,\n  onApiError,\n  authToken,\n  subscriptions,\n  fetchSubscriptions,\n  isFetchingSubscriptions,\n  toast,\n}) {\n  const theme = useTheme()\n\n  const [selectedOrganization, setSelectedOrganization] = useState(\n    DEFAULT_CONSTANT\n  )\n  const [selectedApp, setSelectedApp] = useState(DEFAULT_CONSTANT)\n  const [selectedEvent, setSelectedEvent] = useState(DEFAULT_CONSTANT)\n  const [selectedSubscriptions, setSelectedSubscriptions] = useState([])\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [deleteModalOpened, setDeleteModalOpened] = useState(false)\n\n  const handleSelectEntries = useCallback((entries, indexes) => {\n    setSelectedSubscriptions(indexes)\n  }, [])\n  const onOrganizationChange = useCallback(idx => {\n    setSelectedSubscriptions([])\n    setSelectedOrganization(idx || DEFAULT_CONSTANT)\n  }, [])\n  const onAppChange = useCallback(idx => {\n    setSelectedSubscriptions([])\n    setSelectedApp(idx || DEFAULT_CONSTANT)\n  }, [])\n  const onEventChange = useCallback(idx => {\n    setSelectedSubscriptions([])\n    setSelectedEvent(idx || DEFAULT_CONSTANT)\n  }, [])\n  const onClearFilters = useCallback(() => {\n    setSelectedEvent(DEFAULT_CONSTANT)\n    setSelectedApp(DEFAULT_CONSTANT)\n    setSelectedOrganization(DEFAULT_CONSTANT)\n    // Reset selection when filters cleared\n    setSelectedSubscriptions([])\n  }, [])\n\n  const onClick = useCallback(() => {\n    setDeleteModalOpened(true)\n  }, [])\n  const onCloseModal = useCallback(() => {\n    setDeleteModalOpened(false)\n  }, [])\n\n  const organizations = [\n    'All',\n    ...new Set(subscriptions.map(subscription => subscription.ensName)),\n  ]\n  const subscriptionApps = [\n    'All',\n    ...new Set(subscriptions.map(subscription => subscription.appName)),\n  ]\n  const events = [\n    'All',\n    ...new Set(subscriptions.map(subscription => subscription.eventName)),\n  ]\n  const filteredSubscriptions = useMemo(\n    () =>\n      filterSubscriptions({\n        subscriptions,\n        event: selectedEvent > 0 ? events[selectedEvent] : null,\n        appName: selectedApp > 0 ? subscriptionApps[selectedApp] : null,\n        organization:\n          selectedOrganization > 0 ? organizations[selectedOrganization] : null,\n      }),\n    [\n      events,\n      organizations,\n      selectedApp,\n      selectedEvent,\n      selectedOrganization,\n      subscriptionApps,\n      subscriptions,\n    ]\n  )\n\n  const handleUnsubscribe = useCallback(\n    async e => {\n      setIsSubmitting(true)\n      try {\n        const subscriptionIds = selectedSubscriptions.map(\n          i => filteredSubscriptions[i].subscriptionId\n        )\n        await deleteSubscriptions({\n          subscriptionIds,\n          authToken,\n        })\n\n        // reset selection\n        setIsSubmitting(false)\n        // Clear filters as the filter might no longer be valid as the item has been removed\n        onClearFilters()\n        // Refetch subscriptions\n        fetchSubscriptions()\n        toast('Email notifications unsubscribed')\n      } catch (e) {\n        onApiError(e)\n        setIsSubmitting(false)\n      }\n    },\n    [\n      selectedSubscriptions,\n      authToken,\n      onClearFilters,\n      fetchSubscriptions,\n      toast,\n      filteredSubscriptions,\n      onApiError,\n    ]\n  )\n\n  const onModalConfirm = useCallback(() => {\n    setDeleteModalOpened(false)\n    handleUnsubscribe()\n  }, [handleUnsubscribe])\n\n  return (\n    <React.Fragment>\n      <DataView\n        fields={[\n          {\n            label: 'Organization',\n            priority: 3,\n          },\n          {\n            label: 'App',\n            priority: 2,\n          },\n          {\n            label: 'Contract',\n            priority: 2,\n          },\n          {\n            label: 'Event',\n            priority: 1,\n          },\n        ]}\n        heading={\n          <React.Fragment>\n            <div\n              css={`\n                height: ${9 * GU}px;\n                display: flex;\n                align-items: center;\n                justify-content: space-between;\n              `}\n            >\n              <div\n                css={`\n                  color: ${theme.content};\n                  ${textStyle('body1')}\n                `}\n              >\n                Subscriptions\n              </div>\n              <div>\n                <Button\n                  disabled={selectedSubscriptions.length === 0}\n                  onClick={onClick}\n                >\n                  {isSubmitting ? (\n                    <LoadingRing\n                      css={`\n                        margin-right: ${GU}px;\n                      `}\n                    />\n                  ) : (\n                    <IconMail\n                      css={`\n                        color: ${theme.negative};\n                        margin-right: ${GU}px;\n                      `}\n                    />\n                  )}{' '}\n                  Unsubscribe\n                </Button>\n              </div>\n            </div>\n            <SubscriptionFilters\n              organizations={organizations}\n              selectedOrganization={selectedOrganization}\n              onOrganizationChange={onOrganizationChange}\n              apps={subscriptionApps}\n              appsFull={apps}\n              selectedApp={selectedApp}\n              onAppChange={onAppChange}\n              events={events}\n              selectedEvent={selectedEvent}\n              onEventChange={onEventChange}\n              onClearFilters={onClearFilters}\n            />\n          </React.Fragment>\n        }\n        entries={filteredSubscriptions}\n        onSelectEntries={handleSelectEntries}\n        selection={selectedSubscriptions}\n        renderEntry={(\n          { appName, contractAddress, ensName, eventName },\n          index,\n          { selected, mode }\n        ) => {\n          const appLabel = (() => {\n            const app = apps.find(a => a.contractAddress === contractAddress)\n            if (!app) {\n              return appName\n            }\n            return <LocalLabelAppBadge app={app} apps={apps} />\n          })()\n\n          return [\n            <Label>{ensName}</Label>,\n            <Label>{appLabel} </Label>,\n            <LocalIdentityBadge entity={contractAddress} />,\n            <Label>{eventName}</Label>,\n          ]\n        }}\n      />\n      <DeleteSubscriptionConfirmationModal\n        visible={deleteModalOpened}\n        onConfirm={onModalConfirm}\n        onClose={onCloseModal}\n      />\n    </React.Fragment>\n  )\n})\n\nSubscriptionsTable.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  apiError: PropTypes.string,\n  onApiError: PropTypes.func.isRequired,\n  authToken: PropTypes.string,\n  fetchSubscriptions: PropTypes.func.isRequired,\n  isFetchingSubscriptions: PropTypes.bool,\n  subscriptions: PropTypes.array.isRequired,\n  toast: PropTypes.func.isRequired,\n}\n\nconst Label = styled.label`\n  display: block;\n`\n\nexport default SubscriptionsTable\n","import React, { useState, useEffect, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { AppType } from '../../../prop-types'\nimport {\n  Box,\n  Button,\n  GU,\n  IconTrash,\n  IconCheck,\n  LoadingRing,\n  useToast,\n  useTheme,\n  Split,\n} from '@aragon/ui'\nimport { getSubscriptions, deleteAccount } from './notification-service-api'\nimport {\n  NOTIFICATION_SERVICE_TOKEN_KEY,\n  NOTIFICATION_SERVICE_EMAIL_KEY,\n} from './constants'\nimport SubscriptionsForm from './SubscriptionsForm'\nimport SubscriptionsTable from './SubscriptionsTable'\nimport { DeleteAccountConfirmationModal } from './NotificationModals'\nimport { useWallet } from '../../../contexts/wallet'\n\nexport default function ManageNotifications({\n  apps,\n  email,\n  onLogout,\n  token,\n  onServiceUnavailable,\n}) {\n  const toast = useToast()\n\n  const [apiError, setApiError] = useState(null)\n  const [isFetching, setIsFetching] = useState(true)\n  const [subscriptions, setSubscriptions] = useState([])\n  const { networkType } = useWallet()\n\n  const fetchSubscriptions = useCallback(() => {\n    setIsFetching(true)\n    return getSubscriptions(networkType, token)\n      .then(subscriptions => {\n        setApiError(null) // reset the error after successfully fetching\n        setSubscriptions(subscriptions)\n        setIsFetching(false)\n        return subscriptions\n      })\n      .catch(error => {\n        setIsFetching(false)\n        setApiError(error)\n      })\n  }, [token, networkType])\n\n  useEffect(() => {\n    if (!token) {\n      return\n    }\n    fetchSubscriptions()\n  }, [fetchSubscriptions, token])\n\n  useEffect(() => {\n    // Effect for handling api errors\n    if (!apiError) {\n      return\n    }\n    if (apiError instanceof TypeError) {\n      onServiceUnavailable()\n    } else {\n      console.error('Unhandled API error:', apiError)\n    }\n  }, [apiError, onServiceUnavailable])\n\n  const handleLogout = useCallback(() => {\n    onLogout()\n    toast('Signed out from email notifications')\n  }, [onLogout, toast])\n\n  return (\n    <React.Fragment>\n      <Split\n        primary={\n          <SubscriptionsForm\n            onApiError={setApiError}\n            fetchSubscriptions={fetchSubscriptions}\n            apps={apps}\n            token={token}\n            isFetchingSubscriptions={isFetching}\n            subscriptions={subscriptions}\n          />\n        }\n        secondary={\n          <React.Fragment>\n            <Box heading=\"Signed In With Email\">\n              {email}\n              <Button\n                css={`\n                  margin-top: ${2 * GU}px;\n                `}\n                wide\n                onClick={handleLogout}\n              >\n                Sign out\n              </Button>\n            </Box>\n            <DeleteAccount\n              onApiError={setApiError}\n              token={token}\n              onLogout={onLogout}\n              toast={toast}\n            />\n          </React.Fragment>\n        }\n      />\n      {(apiError || subscriptions.length > 0) && (\n        <SubscriptionsTable\n          apps={apps}\n          apiError={apiError}\n          onApiError={setApiError}\n          authToken={token}\n          subscriptions={subscriptions}\n          fetchSubscriptions={fetchSubscriptions}\n          isFetchingSubscriptions={isFetching}\n          toast={toast}\n        />\n      )}\n    </React.Fragment>\n  )\n}\n\nManageNotifications.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  email: PropTypes.string,\n  onLogout: PropTypes.func,\n  onServiceUnavailable: PropTypes.func,\n  token: PropTypes.string,\n}\n\nfunction DeleteAccount({ token, onLogout, onApiError, toast }) {\n  const theme = useTheme()\n\n  const [isFetching, setIsFetching] = useState(false)\n  const [isAccountDeleted, setIsAccountDeleted] = useState(false)\n  const [deleteAccountModalOpened, setDeleteAccountModalOpened] = useState(\n    false\n  )\n\n  const handleDeleteAccount = useCallback(async () => {\n    try {\n      setIsFetching(true)\n      await deleteAccount(token)\n      localStorage.removeItem(NOTIFICATION_SERVICE_TOKEN_KEY)\n      localStorage.removeItem(NOTIFICATION_SERVICE_EMAIL_KEY)\n      setIsAccountDeleted(true)\n      onLogout()\n      toast('Email notifications account deleted')\n    } catch (e) {\n      onApiError(e)\n    }\n    setIsFetching(false)\n  }, [token, onLogout, toast, onApiError])\n\n  const onClick = useCallback(() => {\n    setDeleteAccountModalOpened(true)\n  }, [])\n\n  const onCloseModal = useCallback(() => {\n    setDeleteAccountModalOpened(false)\n  }, [])\n\n  const onModalConfirm = useCallback(() => {\n    setDeleteAccountModalOpened(false)\n    handleDeleteAccount()\n  }, [handleDeleteAccount])\n\n  return (\n    <React.Fragment>\n      <Box heading=\"Email Notification Data\">\n        <Button wide onClick={onClick}>\n          {isFetching ? (\n            <LoadingRing />\n          ) : isAccountDeleted ? (\n            <IconCheck />\n          ) : (\n            <IconTrash\n              css={`\n                color: ${theme.negative};\n                margin-right: ${GU}px;\n              `}\n            />\n          )}\n          Delete your email\n        </Button>\n      </Box>\n      <DeleteAccountConfirmationModal\n        visible={deleteAccountModalOpened}\n        onConfirm={onModalConfirm}\n        onClose={onCloseModal}\n      />\n    </React.Fragment>\n  )\n}\n\nDeleteAccount.propTypes = {\n  onApiError: PropTypes.func,\n  onLogout: PropTypes.func,\n  token: PropTypes.string,\n  toast: PropTypes.func,\n}\n","import React, { useState, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Box,\n  Button,\n  GU,\n  TextInput,\n  Info,\n  IconMail,\n  IconCross,\n  IconCheck,\n  textStyle,\n  useTheme,\n} from '@aragon/ui'\nimport { login } from './notification-service-api'\nimport { validateEmail } from '../../../util/utils'\nimport { useRouting } from '../../../routing'\nimport notificationPng from './notifications.png'\nimport { useWallet } from '../../../contexts/wallet'\n\nexport default function NotificationsLogin({ onEmailChange, hasLoggedOut }) {\n  const [inputEmail, setInputEmail] = useState('')\n  const [emailInvalid, setEmailInvalid] = useState(null)\n  const [apiError, setApiError] = useState(null)\n  const { networkType } = useWallet()\n\n  const { mode } = useRouting()\n\n  const handleEmailBlur = useCallback(e => {\n    const email = e.target.value\n    setEmailInvalid(!validateEmail(email))\n  }, [])\n\n  const handleEmailChange = useCallback(e => {\n    const email = e.target.value\n    setInputEmail(email)\n    if (validateEmail(email)) {\n      // Set only as valid while user typing. Use blur to set invalid\n      setEmailInvalid(false)\n    }\n  }, [])\n\n  const handleLogin = useCallback(\n    async e => {\n      e && e.preventDefault()\n\n      if (!validateEmail(inputEmail)) {\n        setEmailInvalid(true)\n        return\n      }\n\n      try {\n        await login({ networkType, email: inputEmail, dao: mode.orgAddress })\n        onEmailChange(inputEmail)\n      } catch (e) {\n        setApiError(e.message)\n        console.error('Failed to login', e)\n      }\n    },\n    [mode, inputEmail, onEmailChange, networkType]\n  )\n\n  const theme = useTheme()\n\n  return (\n    <Box heading=\"Email notifications\">\n      <NotificationImage />\n      <form onSubmit={handleLogin}>\n        <div\n          css={`\n            display: grid;\n            align-items: end;\n            grid-template-columns: 1fr auto;\n            grid-gap: ${GU}px ${2 * GU}px;\n            margin-bottom: ${2 * GU}px;\n          `}\n        >\n          <label\n            css={`\n              color: ${theme.surfaceContentSecondary};\n              display: block;\n            `}\n          >\n            Email address\n            <TextInput\n              css={`\n                border-color: ${emailInvalid === true\n                  ? theme.error\n                  : theme.border};\n              `}\n              adornment={\n                emailInvalid ? (\n                  <IconCross\n                    css={`\n                      color: ${theme.negative};\n                    `}\n                  />\n                ) : (\n                  <IconCheck\n                    css={`\n                      opacity: ${inputEmail.trim() ? '1' : '0'};\n                      color: ${theme.positive};\n                    `}\n                  />\n                )\n              }\n              adornmentPosition=\"end\"\n              type=\"email\"\n              placeholder=\"you@example.org\"\n              wide\n              value={inputEmail}\n              onChange={handleEmailChange}\n              onBlur={handleEmailBlur}\n            />\n          </label>\n\n          <Button\n            disabled={emailInvalid !== false}\n            css={`\n              width: ${16 * GU}px;\n            `}\n            onClick={handleLogin}\n            icon={<IconMail />}\n            label=\"Sign in\"\n          />\n          {apiError && (\n            <p\n              css={`\n                color: ${theme.negative};\n                ${textStyle('body4')};\n              `}\n            >\n              Error logging in. Please try again\n            </p>\n          )}\n          {emailInvalid && (\n            <p\n              css={`\n                color: ${theme.negative};\n                ${textStyle('body4')};\n              `}\n            >\n              Please enter a valid email address\n            </p>\n          )}\n        </div>\n      </form>\n\n      <Info>\n        {hasLoggedOut\n          ? `You need to enter with your email address because you are using a\n        different browser session or device to access your subsciptions. This\n        process doens‚Äôt require a password, just for you to confirm your email\n        address.`\n          : `Receive email notifications for new app events. For example,\n        whenever a new vote is created or when funds are transferred, you‚Äôll get\n        an email informing you of this activity in your organization.\n        This process doesn‚Äôt require a password. You will be asked to enter\n        your email address whenever using a different browser session\n        or device to access your notification subscriptions. The email address\n        you enter here is only used to send you notifications that you have\n        explicitly opted into and will not be shared, rented,\n        or sold for any marketing purposes.`}\n      </Info>\n    </Box>\n  )\n}\n\nconst NotificationImage = () => (\n  <img\n    src={notificationPng}\n    alt=\"Notifications\"\n    css={`\n      display: block;\n      margin: ${4 * GU}px auto;\n      height: 193px;\n    `}\n  />\n)\n\nNotificationsLogin.propTypes = {\n  onEmailChange: PropTypes.func,\n  hasLoggedOut: PropTypes.bool,\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { GU, IconCheck, IconCross, useTheme } from '@aragon/ui'\n\nconst FeedbackIndicator = ({ status, ...props }) => {\n  const theme = useTheme()\n  const color =\n    status === 'success'\n      ? theme.positive\n      : status === 'error'\n      ? theme.negative\n      : theme.hint\n\n  return (\n    <div\n      css={`\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: ${8 * GU}px;\n        height: ${8 * GU}px;\n        border: 2px solid ${color};\n        border-radius: 50%;\n        transition: border-color 150ms ease-in-out;\n      `}\n      {...props}\n    >\n      {status === 'error' ? (\n        <IconCross\n          size=\"large\"\n          css={`\n            color: ${color};\n            transition: color 150ms ease-in-out;\n          `}\n        />\n      ) : (\n        <IconCheck\n          size=\"large\"\n          css={`\n            color: ${color};\n            transition: color 150ms ease-in-out;\n          `}\n        />\n      )}\n    </div>\n  )\n}\n\nFeedbackIndicator.propTypes = {\n  status: PropTypes.oneOf(['pending', 'success', 'error']).isRequired,\n}\n\nexport default FeedbackIndicator\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Box, GU, RADIUS, useTheme, textStyle, useViewport } from '@aragon/ui'\nimport notification from './notification.png'\nimport notificationError from './notification-error.png'\nimport notificationNetworkError from './notification-network-error.png'\nimport FeedbackIndicator from '../../FeedbackIndicator/FeedbackIndicator'\n\nexport const ICON_SUCCESS = 'success'\nexport const ICON_NEUTRAL = 'neutral'\nexport const ICON_ERROR = 'error'\nconst ALLOWED_ICONS = [ICON_SUCCESS, ICON_NEUTRAL, ICON_ERROR]\n\nexport const IMAGE_NORMAL = 'IMAGE_NORMAL'\nexport const IMAGE_ERROR = 'IMAGE_ERROR'\nexport const IMAGE_NETWORK_ERROR = 'IMAGE_NETWORK_ERROR'\nconst ALLOWED_IMAGES = [IMAGE_NORMAL, IMAGE_ERROR, IMAGE_NETWORK_ERROR]\n\nexport default function NotificationsInfoBox({\n  header,\n  children,\n  icon,\n  image = IMAGE_NORMAL,\n}) {\n  const { below } = useViewport()\n  const small = below('medium')\n  const theme = useTheme()\n  let IconComponent = null\n  switch (icon) {\n    case ICON_SUCCESS:\n      IconComponent = <FeedbackIndicator status=\"success\" />\n      break\n    case ICON_NEUTRAL:\n      IconComponent = <FeedbackIndicator status=\"pending\" />\n      break\n    case ICON_ERROR:\n      IconComponent = <FeedbackIndicator status=\"error\" />\n      break\n  }\n  let ImageComponent = null\n  switch (image) {\n    case IMAGE_NORMAL:\n      ImageComponent = <NotificationImage />\n      break\n    case IMAGE_ERROR:\n      ImageComponent = <NotificationErrorImage />\n      break\n    case IMAGE_NETWORK_ERROR:\n      ImageComponent = <NotificationNetworkErrorImage />\n      break\n  }\n\n  return (\n    <Box heading=\"Email notifications\">\n      <div\n        css={`\n          margin: ${3 * GU}px auto;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n        `}\n      >\n        {ImageComponent}\n      </div>\n      <div\n        css={`\n          min-height: ${GU * 24}px;\n          background: ${theme.feedbackSurface};\n          display: grid;\n          border-radius: ${RADIUS}px;\n          padding: ${small ? 2 * GU : 3.5 * GU}px ${small ? 3 * GU : 10 * GU}px;\n          grid-gap: ${3 * GU}px;\n          grid-template-columns: ${small || !icon ? '1fr' : 'auto 1fr'};\n          align-items: center;\n          text-align: ${small ? 'center' : 'start'};\n        `}\n      >\n        <div\n          css={`\n            margin: ${small ? '0 auto' : '0'};\n          `}\n        >\n          {' '}\n          {IconComponent}\n        </div>\n        <div>\n          <div\n            css={`\n              margin-bottom: ${1.5 * GU}px;\n              ${textStyle('body1')};\n            `}\n          >\n            <div>{header}</div>\n          </div>\n          <div\n            css={`\n              ${textStyle('body2')};\n              color: ${theme.feedbackSurfaceContentSecondary};\n            `}\n          >\n            {children}\n          </div>\n        </div>\n      </div>\n    </Box>\n  )\n}\n\nNotificationsInfoBox.propTypes = {\n  header: PropTypes.string,\n  children: PropTypes.node,\n  icon: PropTypes.oneOf(ALLOWED_ICONS),\n  image: PropTypes.oneOf(ALLOWED_IMAGES),\n}\n\nconst NotificationImage = () => (\n  <img src={notification} alt=\"Notifications\" height=\"193\" />\n)\n\nconst NotificationErrorImage = () => (\n  <img src={notificationError} alt=\"Notifications error\" height=\"193\" />\n)\n\nconst NotificationNetworkErrorImage = () => (\n  <img\n    src={notificationNetworkError}\n    alt=\"Notifications network error\"\n    height=\"270\"\n  />\n)\n","import React, { useEffect, useCallback, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { Link, GU, LoadingRing, textStyle } from '@aragon/ui'\nimport { verifyEmailToken } from './notification-service-api'\nimport {\n  VERIFY_SUBSECTION,\n  SUCCESSFUL_VERIFICATION_REDIRECTION_DELAY,\n  ExpiredTokenError,\n} from './constants'\nimport NotificationsInfoBox, {\n  ICON_SUCCESS,\n  ICON_ERROR,\n  ICON_NEUTRAL,\n  IMAGE_ERROR,\n  IMAGE_NORMAL,\n} from './NotificationsInfoBox'\n\nexport function NotificationsVerify({\n  subsection,\n  onTokenChange,\n  onEmailChange,\n  navigateToNotifications,\n}) {\n  const [isFetching, setIsFetching] = useState(true)\n  const [verified, setVerified] = useState(false)\n  const [error, setError] = useState(null)\n\n  const handleResetAccount = useCallback(() => {\n    // In error states we can clear email and token to reset the state\n    onEmailChange(null)\n    onTokenChange(null)\n    navigateToNotifications()\n  }, [onEmailChange, onTokenChange, navigateToNotifications])\n\n  useEffect(() => {\n    let cancelled = false\n    // Parse token from subsection /verify/[TOKEN] -> [TOKEN]\n    const token = subsection.substring(VERIFY_SUBSECTION.length)\n    verifyEmailToken(token)\n      .then(longLivedToken => {\n        if (!cancelled) {\n          setVerified(true)\n          setIsFetching(false)\n          onTokenChange(longLivedToken)\n        }\n        return longLivedToken\n      })\n      .catch(e => {\n        if (!cancelled) {\n          setError(e)\n          setIsFetching(false)\n          setVerified(false)\n        }\n      })\n    return () => {\n      cancelled = true\n    }\n  }, [subsection, onTokenChange, onEmailChange])\n\n  // Redirect user automatically after 10 seconds\n  useEffect(() => {\n    let timeoutId\n    if (verified) {\n      timeoutId = setTimeout(() => {\n        navigateToNotifications()\n      }, SUCCESSFUL_VERIFICATION_REDIRECTION_DELAY)\n    }\n    return () => {\n      timeoutId && clearTimeout(timeoutId)\n    }\n  }, [navigateToNotifications, verified])\n\n  if (isFetching) {\n    return (\n      <NotificationsInfoBox image={IMAGE_NORMAL}>\n        <div\n          css={`\n            display: flex;\n            justify-content: center;\n            align-items: center;\n          `}\n        >\n          <LoadingRing />\n          <p\n            css={`\n              margin-left: ${GU}px;\n              ${textStyle('body1')};\n            `}\n          >\n            Verifying...\n          </p>\n        </div>\n      </NotificationsInfoBox>\n    )\n  }\n  if (verified) {\n    return (\n      <NotificationsInfoBox\n        header=\"Verification Successful\"\n        image={IMAGE_NORMAL}\n        icon={ICON_SUCCESS}\n      >\n        <div>\n          Your email was verified and now you can subscribe to app events to\n          receive email notifications. You may close this tab or{' '}\n          <Link\n            css={`\n              font-weight: bold;\n            `}\n            onClick={navigateToNotifications}\n          >\n            go to Notification preferences\n          </Link>\n          .\n        </div>\n      </NotificationsInfoBox>\n    )\n  }\n\n  let message\n  if (error && error instanceof ExpiredTokenError) {\n    message = <div>The link you used to verify your email has expired.</div>\n  } else if (error && error instanceof TypeError) {\n    message = (\n      <div>\n        There was an error when trying to connect to the Notifications server.\n      </div>\n    )\n  } else {\n    message = (\n      <div>Something has gone wrong during the email verification process.</div>\n    )\n  }\n\n  return (\n    <NotificationsInfoBox\n      header=\"Verification Failed\"\n      icon={ICON_ERROR}\n      image={IMAGE_ERROR}\n    >\n      {message} Don't worry, you can go back and\n      <Link\n        css={`\n          font-weight: bold;\n        `}\n        onClick={handleResetAccount}\n      >\n        try to sign in again\n      </Link>\n      .\n    </NotificationsInfoBox>\n  )\n}\n\nNotificationsVerify.propTypes = {\n  subsection: PropTypes.string,\n  onTokenChange: PropTypes.func,\n  onEmailChange: PropTypes.func,\n  navigateToNotifications: PropTypes.func,\n}\n\nexport function NotificationsPreVerify({ email, onEmailChange }) {\n  const handleResetEmail = useCallback(() => onEmailChange(null), [\n    onEmailChange,\n  ])\n  return (\n    <NotificationsInfoBox\n      icon={ICON_NEUTRAL}\n      header=\"Awaiting verification. Please check your email!\"\n    >\n      <p>\n        We‚Äôve sent an email to <strong>{email}</strong>. Verify your email\n        address so you can manage your notifications subscriptions.\n      </p>\n      <p>\n        Something went wrong?{' '}\n        <Link\n          css={`\n            font-weight: bold;\n          `}\n          onClick={handleResetEmail}\n        >\n          Go back and try to sign in again\n        </Link>\n        .\n      </p>\n    </NotificationsInfoBox>\n  )\n}\nNotificationsPreVerify.propTypes = {\n  email: PropTypes.string,\n  onEmailChange: PropTypes.func,\n}\n","import React, { useState, useEffect, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { AppType } from '../../../prop-types'\nimport { Link, GU, LoadingRing, textStyle } from '@aragon/ui'\nimport ManageNotifications from './ManageNotifications'\nimport NotificationsLogin from './NotificationsLogin'\nimport {\n  NotificationsVerify,\n  NotificationsPreVerify,\n} from './NotificationsVerify'\nimport NotificationsInfoBox, {\n  ICON_ERROR,\n  IMAGE_NETWORK_ERROR,\n  IMAGE_ERROR,\n} from './NotificationsInfoBox'\nimport { isAuthTokenValid } from './notification-service-api'\n\nimport {\n  AUTH_UNAUTHENTICATED,\n  AUTH_PREVERIFY,\n  AUTH_AUTHENTICATED,\n  AUTH_AUTHENTICATION_FAILED,\n  AUTH_SERVICE_UNAVAILABLE,\n  NOTIFICATION_SERVICE_EMAIL_KEY,\n  NOTIFICATION_SERVICE_TOKEN_KEY,\n  NOTIFICATION_SERVICE_HAS_LOGGED_OUT_KEY,\n  VERIFY_SUBSECTION,\n  AUTH_AUTHENTICATING,\n} from './constants'\n\n// Hook responsible for deriving the authState from localStorage values and\n// providing setters which update the localStorage\nfunction useAuthState() {\n  const [authState, setAuthState] = useState(AUTH_UNAUTHENTICATED)\n  const [email, setEmail] = useState(\n    localStorage.getItem(NOTIFICATION_SERVICE_EMAIL_KEY)\n  )\n  const [token, setToken] = useState(\n    localStorage.getItem(NOTIFICATION_SERVICE_TOKEN_KEY)\n  )\n  const [hasLoggedOut, setHasLoggedOut] = useState(\n    localStorage.getItem(NOTIFICATION_SERVICE_HAS_LOGGED_OUT_KEY) === '1'\n  )\n\n  const handleAuthenticate = useCallback(() => {\n    setAuthState(AUTH_AUTHENTICATING)\n    isAuthTokenValid(token)\n      .then(v => {\n        setAuthState(AUTH_AUTHENTICATED)\n        return v\n      })\n      .catch(e => {\n        if (e instanceof TypeError) {\n          // network/service error\n          setAuthState(AUTH_SERVICE_UNAVAILABLE)\n        } else {\n          setAuthState(AUTH_AUTHENTICATION_FAILED)\n        }\n      })\n  }, [token])\n\n  useEffect(() => {\n    if (!email && !token) {\n      setAuthState(AUTH_UNAUTHENTICATED)\n      return\n    }\n\n    if (email && !token) {\n      setAuthState(AUTH_PREVERIFY)\n      return\n    }\n\n    if (email && token) {\n      handleAuthenticate()\n    }\n  }, [email, token, handleAuthenticate])\n\n  useEffect(() => {\n    token\n      ? localStorage.setItem(NOTIFICATION_SERVICE_TOKEN_KEY, token)\n      : localStorage.removeItem(NOTIFICATION_SERVICE_TOKEN_KEY)\n  }, [token])\n\n  useEffect(() => {\n    email\n      ? localStorage.setItem(NOTIFICATION_SERVICE_EMAIL_KEY, email)\n      : localStorage.removeItem(NOTIFICATION_SERVICE_EMAIL_KEY)\n  }, [email])\n\n  useEffect(() => {\n    hasLoggedOut\n      ? localStorage.setItem(NOTIFICATION_SERVICE_HAS_LOGGED_OUT_KEY, '1')\n      : localStorage.removeItem(NOTIFICATION_SERVICE_HAS_LOGGED_OUT_KEY)\n  }, [hasLoggedOut])\n\n  const handleLogout = useCallback(() => {\n    setEmail(null)\n    setToken(null)\n    // Set hasUsed to show a different login for previously logged in users\n    setHasLoggedOut(true)\n  }, [])\n\n  const setServiceUnavailable = useCallback(() => {\n    setAuthState(AUTH_SERVICE_UNAVAILABLE)\n  }, [])\n\n  return {\n    authState,\n    email,\n    token,\n    hasLoggedOut,\n    handleTokenChange: setToken,\n    handleEmailChange: setEmail,\n    handleLogout,\n    setServiceUnavailable,\n    handleAuthenticate,\n  }\n}\n\nexport default function Notifications({\n  apps,\n  subsection,\n  handleNavigation,\n  navigationIndex,\n}) {\n  const {\n    authState,\n    email,\n    token,\n    hasLoggedOut,\n    handleAuthenticate,\n    handleTokenChange,\n    handleEmailChange,\n    handleLogout,\n    setServiceUnavailable,\n  } = useAuthState()\n\n  const navigateToNotifications = useCallback(\n    () => handleNavigation(navigationIndex),\n    [handleNavigation, navigationIndex]\n  )\n\n  if (subsection && subsection.startsWith(VERIFY_SUBSECTION)) {\n    return (\n      <NotificationsVerify\n        subsection={subsection}\n        onTokenChange={handleTokenChange}\n        onEmailChange={handleEmailChange}\n        navigateToNotifications={navigateToNotifications}\n      />\n    )\n  }\n\n  switch (authState) {\n    case AUTH_PREVERIFY:\n      return (\n        <NotificationsPreVerify\n          email={email}\n          onEmailChange={handleEmailChange}\n        />\n      )\n    case AUTH_AUTHENTICATED:\n      return (\n        <ManageNotifications\n          onServiceUnavailable={setServiceUnavailable}\n          onLogout={handleLogout}\n          apps={apps}\n          email={email}\n          token={token}\n        />\n      )\n    case AUTH_AUTHENTICATING:\n      return (\n        <NotificationsInfoBox>\n          <div\n            css={`\n              display: flex;\n              justify-content: center;\n              align-items: center;\n              min-height: ${25 * GU}px;\n            `}\n          >\n            <LoadingRing />\n            <p\n              css={`\n                margin-left: ${GU}px;\n                ${textStyle('body1')};\n              `}\n            >\n              Authenticating‚Ä¶\n            </p>\n          </div>\n        </NotificationsInfoBox>\n      )\n    case AUTH_AUTHENTICATION_FAILED:\n      return (\n        <NotificationsInfoBox\n          header=\"Authentication Failed\"\n          icon={ICON_ERROR}\n          image={IMAGE_ERROR}\n        >\n          <div>\n            Authentication was unsuccessful.{' '}\n            <Link\n              css={`\n                font-weight: bold;\n              `}\n              onClick={handleLogout}\n            >\n              Try logging in again\n            </Link>\n            .\n          </div>\n        </NotificationsInfoBox>\n      )\n    case AUTH_SERVICE_UNAVAILABLE:\n      return (\n        <NotificationsInfoBox\n          header=\"Error connecting to the notifications server\"\n          icon={ICON_ERROR}\n          image={IMAGE_NETWORK_ERROR}\n        >\n          <div>\n            There was an error when trying to connect to the notifications\n            server. Please{' '}\n            <Link\n              css={`\n                font-weight: bold;\n              `}\n              onClick={handleLogout}\n            >\n              sign out\n            </Link>\n            or\n            <Link\n              css={`\n                font-weight: bold;\n              `}\n              onClick={handleAuthenticate}\n            >\n              try again\n            </Link>\n            .\n          </div>\n        </NotificationsInfoBox>\n      )\n    case AUTH_UNAUTHENTICATED:\n    default:\n      return (\n        <NotificationsLogin\n          hasLoggedOut={hasLoggedOut}\n          onEmailChange={handleEmailChange}\n        />\n      )\n  }\n}\n\nNotifications.propTypes = {\n  apps: PropTypes.arrayOf(AppType).isRequired,\n  subsection: PropTypes.string,\n  handleNavigation: PropTypes.func,\n  navigationIndex: PropTypes.number,\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { ToastHub } from '@aragon/ui'\n\nconst TIMEOUT_TOAST = 4000\n\nfunction CustomToast({ children }) {\n  return <ToastHub timeout={TIMEOUT_TOAST}>{children}</ToastHub>\n}\n\nCustomToast.propTypes = {\n  children: PropTypes.node.isRequired,\n}\n\nexport { TIMEOUT_TOAST }\nexport default CustomToast\n","import React, { useEffect, useRef, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  Button,\n  ButtonIcon,\n  GU,\n  IconCopy,\n  Modal,\n  TextInput,\n  useToast,\n  textStyle,\n  useTheme,\n  useViewport,\n} from '@aragon/ui'\nimport { TIMEOUT_TOAST } from '../../CustomToast/CustomToast'\n\nfunction ShareModal({ onClose, link, visible }) {\n  const toast = useToast()\n  const { inputRef, handleCopy, handleFocus } = useShareModal({\n    visible,\n    onClose,\n    toast,\n  })\n  const theme = useTheme()\n  const { above } = useViewport()\n\n  return (\n    <Modal visible={visible} onClose={onClose} css=\"z-index: 2;\">\n      <h1\n        css={`\n          ${textStyle('title2')}\n        `}\n      >\n        Share custom labels\n      </h1>\n      <main\n        css={`\n          margin-top: ${2 * GU}px;\n        `}\n      >\n        <div\n          css={`\n            ${textStyle('body2')}\n            margin-bottom: ${2.5 * GU}px;\n          `}\n        >\n          These labels will be shared with everyone that has access to this\n          link.\n        </div>\n        <div>\n          <div\n            css={`\n              ${textStyle('label2')}\n              color: ${theme.surfaceContentSecondary};\n              margin-bottom: ${1 * GU}px;\n            `}\n          >\n            Link\n          </div>\n          <TextInput\n            ref={inputRef}\n            value={link}\n            onFocus={handleFocus}\n            adornment={\n              <ButtonIcon\n                onClick={handleCopy}\n                label=\"Copy to clipboard\"\n                css={`\n                  width: 38px;\n                  height: 38px;\n                  &:active {\n                    background: ${theme.surfacePressed};\n                  }\n                `}\n              >\n                <IconCopy\n                  css={`\n                    color: ${theme.surfaceIcon};\n                  `}\n                />\n              </ButtonIcon>\n            }\n            adornmentPosition=\"end\"\n            adornmentSettings={{\n              width: 64,\n              padding: 1,\n            }}\n            readOnly\n            wide\n            css={`\n              text-overflow: ellipsis;\n            `}\n          />\n        </div>\n      </main>\n      <div\n        css={`\n          margin-top: ${3 * GU}px;\n          display: flex;\n          justify-content: space-between;\n          text-align: right;\n          ${above('medium') &&\n            `\n              display: block;\n            `}\n        `}\n      >\n        <Button label=\"Close modal\" onClick={onClose}>\n          Close\n        </Button>\n        <Button\n          mode=\"strong\"\n          label=\"Copy link to clipboard\"\n          onClick={handleCopy}\n          css={`\n            margin-left: ${2 * GU}px;\n          `}\n        >\n          Copy link\n        </Button>\n      </div>\n    </Modal>\n  )\n}\n\nShareModal.propTypes = {\n  onClose: PropTypes.func.isRequired,\n  link: PropTypes.string.isRequired,\n  visible: PropTypes.bool.isRequired,\n}\n\nfunction useShareModal({ visible, toast, onClose }) {\n  const inputRef = useRef()\n  const handleFocus = useCallback(() => {\n    inputRef.current.select()\n  }, [inputRef])\n  const handleCopy = useCallback(() => {\n    inputRef.current.focus()\n    inputRef.current.select()\n    try {\n      document.execCommand('copy')\n      toast('Custom labels link copied successfully')\n      setTimeout(onClose, (TIMEOUT_TOAST * 7) / 8)\n    } catch (err) {\n      console.warn(err)\n    }\n  }, [toast, inputRef, onClose])\n\n  useEffect(() => {\n    if (visible) {\n      setTimeout(() => inputRef.current.focus(), 0)\n    }\n  }, [visible])\n\n  return { inputRef, handleCopy, handleFocus }\n}\n\nexport default React.memo(ShareModal)\n","import React, { useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { Button, GU, Modal, textStyle, useToast, useViewport } from '@aragon/ui'\n\nfunction RemoveModal({ visible, onClose, onConfirm }) {\n  const toast = useToast()\n  const { above } = useViewport()\n  const handleConfirm = useCallback(() => {\n    toast('Custom labels removed successfully')\n    onConfirm()\n  }, [onConfirm, toast])\n\n  return (\n    <Modal visible={visible} onClose={onClose} css=\"z-index: 2;\">\n      <h1\n        css={`\n          ${textStyle('title2')}\n        `}\n      >\n        Remove labels\n      </h1>\n      <p\n        css={`\n          margin-top: ${2 * GU}px;\n        `}\n      >\n        This action will irreversibly delete the selected labels you have added\n        to your organization on this device.\n      </p>\n      <div\n        css={`\n          margin-top: ${3 * GU}px;\n          display: grid;\n          grid-gap: ${1.5 * GU}px;\n          grid-template-columns: 1fr 1fr;\n          ${above('medium') &&\n            `\n              display: flex;\n              justify-content: flex-end;\n            `}\n        `}\n      >\n        <Button label=\"Cancel\" onClick={onClose}>\n          Cancel\n        </Button>\n        <Button\n          label=\"Remove labels\"\n          mode=\"strong\"\n          onClick={handleConfirm}\n          css={`\n            ${above('medium') &&\n              `\n                margin-left: ${1.5 * GU}px;\n              `}\n          `}\n        >\n          Remove\n        </Button>\n      </div>\n    </Modal>\n  )\n}\n\nRemoveModal.propTypes = {\n  visible: PropTypes.bool,\n  onClose: PropTypes.func.isRequired,\n  onConfirm: PropTypes.func.isRequired,\n}\n\nexport default React.memo(RemoveModal)\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","export const COMMON_MIME_TYPES = new Map([\n    ['avi', 'video/avi'],\n    ['gif', 'image/gif'],\n    ['ico', 'image/x-icon'],\n    ['jpeg', 'image/jpeg'],\n    ['jpg', 'image/jpeg'],\n    ['mkv', 'video/x-matroska'],\n    ['mov', 'video/quicktime'],\n    ['mp4', 'video/mp4'],\n    ['pdf', 'application/pdf'],\n    ['png', 'image/png'],\n    ['zip', 'application/zip'],\n    ['doc', 'application/msword'],\n    ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']\n]);\n\n\nexport function toFileWithPath(file: FileWithPath, path?: string): FileWithPath {\n    const f = withMimeType(file);\n    if (typeof f.path !== 'string') { // on electron, path is already set to the absolute path\n        const {webkitRelativePath} = file as FileWithWebkitPath;\n        Object.defineProperty(f, 'path', {\n            value: typeof path === 'string'\n                ? path\n                // If <input webkitdirectory> is set,\n                // the File will have a {webkitRelativePath} property\n                // https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/webkitdirectory\n                : typeof webkitRelativePath === 'string' && webkitRelativePath.length > 0\n                    ? webkitRelativePath\n                    : file.name,\n            writable: false,\n            configurable: false,\n            enumerable: true\n        });\n    }\n\n    return f;\n}\n\ninterface DOMFile extends Blob {\n    readonly lastModified: number;\n    readonly name: string;\n}\n\nexport interface FileWithPath extends DOMFile {\n    readonly path?: string;\n}\n\ninterface FileWithWebkitPath extends File {\n    readonly webkitRelativePath?: string;\n}\n\nfunction withMimeType(file: FileWithPath) {\n    const {name} = file;\n    const hasExtension = name && name.lastIndexOf('.') !== -1;\n\n    if (hasExtension && !file.type) {\n        const ext = name.split('.')\n            .pop()!.toLowerCase();\n        const type = COMMON_MIME_TYPES.get(ext);\n        if (type) {\n            Object.defineProperty(file, 'type', {\n                value: type,\n                writable: false,\n                configurable: false,\n                enumerable: true\n            });\n        }\n    }\n\n    return file;\n}\n","import {FileWithPath, toFileWithPath} from './file';\n\n\nconst FILES_TO_IGNORE = [\n    // Thumbnail cache files for macOS and Windows\n    '.DS_Store', // macOs\n    'Thumbs.db'  // Windows\n];\n\n\n/**\n * Convert a DragEvent's DataTrasfer object to a list of File objects\n * NOTE: If some of the items are folders,\n * everything will be flattened and placed in the same list but the paths will be kept as a {path} property.\n * @param evt\n */\nexport async function fromEvent(evt: Event): Promise<(FileWithPath | DataTransferItem)[]> {\n    return isDragEvt(evt) && evt.dataTransfer\n        ? getDataTransferFiles(evt.dataTransfer, evt.type)\n        : getInputFiles(evt);\n}\n\nfunction isDragEvt(value: any): value is DragEvent {\n    return !!value.dataTransfer;\n}\n\nfunction getInputFiles(evt: Event) {\n    const files = isInput(evt.target)\n        ? evt.target.files\n            ? fromList<FileWithPath>(evt.target.files)\n            : []\n        : [];\n    return files.map(file => toFileWithPath(file));\n}\n\nfunction isInput(value: EventTarget | null): value is HTMLInputElement {\n    return value !== null;\n}\n\nasync function getDataTransferFiles(dt: DataTransfer, type: string) {\n    // IE11 does not support dataTransfer.items\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/items#Browser_compatibility\n    if (dt.items) {\n        const items = fromList<DataTransferItem>(dt.items)\n            .filter(item => item.kind === 'file');\n        // According to https://html.spec.whatwg.org/multipage/dnd.html#dndevents,\n        // only 'dragstart' and 'drop' has access to the data (source node)\n        if (type !== 'drop') {\n            return items;\n        }\n        const files = await Promise.all(items.map(toFilePromises));\n        return noIgnoredFiles(flatten<FileWithPath>(files));\n    }\n\n    return noIgnoredFiles(fromList<FileWithPath>(dt.files)\n        .map(file => toFileWithPath(file)));\n}\n\nfunction noIgnoredFiles(files: FileWithPath[]) {\n    return files.filter(file => FILES_TO_IGNORE.indexOf(file.nameÄÄ